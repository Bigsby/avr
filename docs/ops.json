[
    {
        "mnemonic": "adc",
        "opCode": "0001 11rd dddd rrrr",
        "flags": "Z,C,N,V,S,H",
        "status": {
            "H": "Rd3 • Rr3 + Rr3 • R3 + R3 • Rd3",
            "V": "Rd7 • Rr7 • R7 + Rd7 • Rr7 • R7",
            "N": "R7",
            "Z": "R7 • R6 • R5 • R4 • R3 • R2 • R1 • R0",
            "C": "Rd7 • Rr7 + Rr7 • R7 + R7 • Rd7"
        },
        "operation": "Rd ← Rd + Rr + C",
        "operands": {
            "d": "0 ≤ d ≤ 31",
            "r": "0 ≤ r ≤ 31"
        },
        "syntax": "ADC Rd,Rr",
        "pCounter": "PC ← PC + 1",
        "type": "AL",
        "description": "Add with Carry"
    },
    {
        "mnemonic": "add",
        "description": "Add without Carry",
        "operation": "Rd ← Rd + Rr",
        "flags": "Z,C,N,V,S,H",
        "type": "AL"
    },
    {
        "mnemonic": "adiw",
        "description": "Add Immediate to Word",
        "operation": "Rd ← Rd + 1:Rd + K",
        "flags": "Z,C,N,V,S",
        "type": "AL"
    },
    {
        "mnemonic": "sub",
        "description": "Subtract without Carry",
        "operation": "Rd ← Rd - Rr",
        "flags": "Z,C,N,V,S,H",
        "type": "AL"
    },
    {
        "mnemonic": "subi",
        "description": "Subtract Immediate",
        "operation": "Rd ← Rd - K",
        "flags": "Z,C,N,V,S,H",
        "type": "AL"
    },
    {
        "mnemonic": "sbc",
        "description": "Subtract with Carry",
        "operation": "Rd ← Rd - Rr - C",
        "flags": "Z,C,N,V,S,H",
        "type": "AL"
    },
    {
        "mnemonic": "sbci",
        "description": "Subtract Immediate with Carry",
        "operation": "Rd ← Rd - K - C",
        "flags": "Z,C,N,V,S,H",
        "type": "AL"
    },
    {
        "mnemonic": "sbiw",
        "description": "Subtract Immediate from Word",
        "operation": "Rd + 1:Rd ← Rd + 1:Rd - K",
        "flags": "Z,C,N,V,S",
        "type": "AL"
    },
    {
        "mnemonic": "and",
        "description": "Logical AND",
        "operation": "Rd ← Rd • Rr",
        "flags": "Z,N,V,S",
        "type": "AL"
    },
    {
        "mnemonic": "andi",
        "description": "Logical AND with Immediate",
        "operation": "Rd ← Rd • K",
        "flags": "Z,N,V,S",
        "type": "AL"
    },
    {
        "mnemonic": "or",
        "description": "Logical OR",
        "operation": "Rd ← Rd v Rr",
        "flags": "Z,N,V,S",
        "type": "AL"
    },
    {
        "mnemonic": "ori",
        "description": "Logical OR with Immediate",
        "operation": "Rd v K",
        "flags": "Z,N,V,S",
        "type": "AL"
    },
    {
        "mnemonic": "eor",
        "description": "Exclusive OR",
        "operation": "Rd ← Rd ⊕ Rr",
        "flags": "Z,N,V,S",
        "type": "AL"
    },
    {
        "mnemonic": "com",
        "description": "One's Complement",
        "operation": "Rd ← $FF - Rd",
        "flags": "Z,C,N,V,S",
        "type": "AL"
    },
    {
        "mnemonic": "neg",
        "description": "Two’s Complement",
        "operation": "Rd ← $00 - Rd",
        "flags": "Z,C,N,V,S,H",
        "type": "AL"
    },
    {
        "mnemonic": "sbr",
        "description": "Set Bit(s) in Register",
        "operation": "Rd ← Rd v K",
        "flags": "Z,N,V,S",
        "type": "AL"
    },
    {
        "mnemonic": "cbr",
        "description": "Clear Bit(s) in Register",
        "operation": "Rd ← Rd • ($FFh -K)",
        "flags": "Z,N,V,S",
        "type": "AL"
    },
    {
        "mnemonic": "inc",
        "description": "Increment",
        "operation": "Rd ← Rd + 1 ",
        "flags": "Z,N,V,S",
        "type": "AL"
    },
    {
        "mnemonic": "dec",
        "description": "Decrement",
        "operation": "Rd ← Rd - 1",
        "flags": "Z,N,V,S",
        "type": "AL"
    },
    {
        "mnemonic": "tst",
        "description": "Test for Zero or Minus",
        "operation": "Rd ← Rd • Rd",
        "flags": "Z,N,V,S",
        "type": "AL"
    },
    {
        "mnemonic": "clr",
        "description": "Clear Register",
        "operation": "Rd ← Rd ⊕ Rd",
        "flags": "Z,N,V,S",
        "type": "AL"
    },
    {
        "mnemonic": "ser",
        "description": "Set Register",
        "operation": "Rd ← $FF",
        "flags": "",
        "type": "AL"
    },
    {
        "mnemonic": "mul",
        "description": "Multiply Unsigned",
        "operation": "R1:R0 ← Rd x Rr (UU)",
        "flags": "Z,C",
        "type": "AL"
    },
    {
        "mnemonic": "muls",
        "description": "Multiply Signed",
        "operation": "R1:R0 ← Rd x Rr (SS)",
        "flags": "Z,C",
        "type": "AL"
    },
    {
        "mnemonic": "mulsu",
        "description": "Multiply Signed with Unsigned",
        "operation": "R1:R0 ← Rd x Rr (SU)",
        "flags": "Z,C",
        "type": "AL"
    },
    {
        "mnemonic": "fmul",
        "description": "Fractional Multiply Unsigned",
        "operation": "R1:R0 ← Rd x Rr<<1 (UU)",
        "flags": "Z,C",
        "type": "AL"
    },
    {
        "mnemonic": "fmuls",
        "description": "Fractional Multiply Signed",
        "operation": "R1:R0 ← Rd x Rr<<1 (SS)",
        "flags": "Z,C",
        "type": "AL"
    },
    {
        "mnemonic": "fmulsu",
        "description": "Fractional Multiply Signed with Unsigned",
        "operation": "R1:R0 ← Rd x Rr<<1 (SU)",
        "flags": "Z,C",
        "type": "AL"
    },
    {
        "mnemonic": "des",
        "description": "Data Encryption",
        "operation": [
            "if (H = 0) then R15:R0 ← Encrypt(R15:R0, K)",
            "else if (H = 1) then R15:R0 ← Decrypt(R15:R0, K)"
        ],
        "flags": "",
        "type": "AL"
    },
    {
        "mnemonic": "rjmp",
        "description": "Relative Jump",
        "operation": "PC ← PC + k + 1",
        "type": "B"
    },
    {
        "mnemonic": "ijmp",
        "description": "Indirect Jump to (Z)",
        "operation": [
            "PC(15:0) ← Z",
            "PC(21:16) ← 0"
        ],
        "type": "B"
    },
    {
        "mnemonic": "eijmp",
        "description": "Extended Indirect Jump to (Z)",
        "operation": [
            "PC(15:0) ← Z",
            "PC(21:16) ← EIND"
        ],
        "type": "B"
    },
    {
        "mnemonic": "jmp",
        "description": "Jump",
        "operation": "PC ← k",
        "type": "B"
    },
    {
        "mnemonic": "rcall",
        "description": "Relative Call Subroutine",
        "operation": "PC ← PC + k + 1",
        "type": "B"
    },
    {
        "mnemonic": "icall",
        "description": "Indirect Call to (Z)",
        "operation": [
            "PC(15:0) ← Z",
            "PC(21:16) ← 0"
        ],
        "type": "B"
    },
    {
        "mnemonic": "eicall",
        "description": "Extended Indirect Call to (Z)",
        "operation": [
            "PC(15:0) ← Z",
            "PC(21:16) ← EIND"
        ],
        "type": "B"
    },
    {
        "mnemonic": "call",
        "description": "Call Subroutine",
        "operation": "PC ← k",
        "type": "B"
    },
    {
        "mnemonic": "ret",
        "description": "Subroutine Return",
        "operation": "PC ← STACK",
        "type": "B"
    },
    {
        "mnemonic": "reti",
        "description": "Interrupt Return",
        "operation": "PC ← STACK",
        "flags": "I",
        "type": "B"
    },
    {
        "mnemonic": "cpse",
        "description": "Compare, skip if Equal",
        "operation": "if (Rd = Rr) PC ← PC + 2 or 3",
        "type": "B"
    },
    {
        "mnemonic": "cp",
        "description": "Compare",
        "operation": "Rd - Rr",
        "flags": "Z,C,N,V,S,H",
        "type": "B"
    },
    {
        "mnemonic": "cpc",
        "description": "Compare with Carry",
        "operation": "Rd - Rr - C",
        "flags": "Z,C,N,V,S,H",
        "type": "B"
    },
    {
        "mnemonic": "cpi",
        "description": "Compare with Immediate",
        "operation": "Rd - K",
        "flags": "Z,C,N,V,S,H",
        "type": "B"
    },
    {
        "mnemonic": "sbrc",
        "description": "Skip if Bit in Register Cleared",
        "operation": "if (Rr(b) = 0) PC ← PC + 2 or 3",
        "type": "B"
    },
    {
        "mnemonic": "sbrs",
        "description": "Skip if Bit in Register Set",
        "operation": "if (Rr(b) = 1) PC ← PC + 2 or 3",
        "type": "B"
    },
    {
        "mnemonic": "sbic",
        "description": "Skip if Bit in I/O Register Cleared",
        "operation": "if (I/O(A,b) = 0) PC ← PC + 2 or 3",
        "type": "B"
    },
    {
        "mnemonic": "sbis",
        "description": "Skip if Bit in I/O Register Set",
        "operation": "If (I/O(A,b) =1) PC ← PC + 2 or 3 ",
        "type": "B"
    },
    {
        "mnemonic": "brbs",
        "description": "Branch if Status Flag Set",
        "operation": "if (SREG(s) = 1) then PC ← PC + k + 1",
        "type": "B"
    },
    {
        "mnemonic": "brbc",
        "description": "Branch if Status Flag Cleared",
        "operation": "if (SREG(s) = 0) then PC ← PC + k + 1",
        "type": "B"
    },
    {
        "mnemonic": "breq",
        "description": "Branch if Equal",
        "operation": "if (Z = 1) then PC ← PC + k + 1",
        "type": "B"
    },
    {
        "mnemonic": "brne",
        "description": "Branch if Not Equal",
        "operation": "if (Z = 0) then PC ← PC + k + 1",
        "type": "B"
    },
    {
        "mnemonic": "brcs",
        "description": "Branch if Carry Set",
        "operation": "if (C = 1) then PC ← PC + k + 1",
        "type": "B"
    },
    {
        "mnemonic": "brcc",
        "description": "Branch if Carry Cleared",
        "operation": "if (C = 0) then PC ← PC + k + 1",
        "type": "B"
    },
    {
        "mnemonic": "brsh",
        "description": "Branch if Same or Higher",
        "operation": "if (C = 0) then PC ← PC + k + 1",
        "type": "B"
    },
    {
        "mnemonic": "brlo",
        "description": "Branch if Lower",
        "operation": "if (C = 1) then PC ← PC + k + 1",
        "type": "B"
    },
    {
        "mnemonic": "brmi",
        "description": "Branch if Minus",
        "operation": "if (N = 1) then PC ← PC + k + 1",
        "type": "B"
    },
    {
        "mnemonic": "brpl",
        "description": "Branch if Plus",
        "operation": "if (N = 0) then PC ← PC + k + 1",
        "type": "B"
    },
    {
        "mnemonic": "brge",
        "description": "Branch if Greater or Equal, Signed",
        "operation": "if (N ⊕ V= 0) then PC ← PC + k + 1",
        "type": "B"
    },
    {
        "mnemonic": "brlt",
        "description": "Branch if Less Than, Signed",
        "operation": "if (N ⊕ V= 1) then PC ← PC + k + 1",
        "type": "B"
    },
    {
        "mnemonic": "brhs",
        "description": "Branch if Half Carry Flag Set",
        "operation": "if (H = 1) then PC ← PC + k + 1",
        "type": "B"
    },
    {
        "mnemonic": "brhc",
        "description": "Branch if Half Carry Flag Cleared",
        "operation": "if (H = 0) then PC ← PC + k + 1",
        "type": "B"
    },
    {
        "mnemonic": "brts",
        "description": "Branch if T Flag Set",
        "operation": "if (T = 1) then PC ← PC + k + 1",
        "type": "B"
    },
    {
        "mnemonic": "brtc",
        "description": "Branch if T Flag Cleared",
        "operation": "if (T = 0) then PC ← PC + k + 1",
        "type": "B"
    },
    {
        "mnemonic": "brvs",
        "description": "Branch if Overflow Flag is Set",
        "operation": "if (V = 1) then PC ← PC + k + 1 ",
        "type": "B"
    },
    {
        "mnemonic": "brvc",
        "description": "Branch if Overflow Flag is Cleared",
        "operation": "if (V = 0) then PC ← PC + k + 1",
        "type": "B"
    },
    {
        "mnemonic": "brie",
        "description": "Branch if Interrupt Enabled",
        "operation": "if (I = 1) then PC ← PC + k + 1",
        "type": "B"
    },
    {
        "mnemonic": "brid",
        "description": "Branch if Interrupt Disabled",
        "operation": "if (I = 0) then PC ← PC + k + 1 ",
        "type": "B"
    },
    {
        "mnemonic": "mov",
        "description": "Copy Register",
        "operation": "Rd ← Rr",
        "type": "DT"
    },
    {
        "mnemonic": "movw",
        "description": "Copy Register Pair",
        "operation": "Rd+1:Rd ← Rr+1:Rr",
        "type": "DT"
    },
    {
        "mnemonic": "ldi",
        "description": "Load Immediate",
        "operation": "Rd ← K",
        "type": "DT"
    },
    {
        "mnemonic": "lds",
        "description": "Load Direct from data space",
        "operation": "Rd ← (k)",
        "type": "DT"
    },
    {
        "mnemonic": "ld",
        "description": "Load Indirect",
        "operation": "Rd ← (X)",
        "type": "DT"
    },
    {
        "mnemonic": "ld",
        "description": "Load Indirect and PostIncrement",
        "operation": [
            "Rd ← (X)",
            "X ← X + 1"
        ],
        "type": "DT"
    },
    {
        "mnemonic": "ld",
        "description": "Load Indirect and PreDecrement",
        "operation": [
            "X ← X - 1",
            "Rd ← (X)"
        ],
        "type": "DT"
    },
    {
        "mnemonic": "ld",
        "description": "Load Indirect",
        "operation": "Rd ← (Y)",
        "type": "DT"
    },
    {
        "mnemonic": "ld",
        "description": "Load Indirect and PostIncrement",
        "operation": [
            "Rd ← (Y)",
            "Y ← Y + 1"
        ],
        "type": "DT"
    },
    {
        "mnemonic": "ld",
        "description": "Load Indirect and PreDecrement",
        "operation": [
            "Y ← Y - 1",
            "Rd ← (Y)"
        ],
        "type": "DT"
    },
    {
        "mnemonic": "ldd",
        "description": "Load Indirect with Displacement",
        "operation": "Rd ← (Y + q)",
        "type": "DT"
    },
    {
        "mnemonic": "ld",
        "description": "Load Indirect",
        "operation": "Rd ← (Z)",
        "type": "DT"
    },
    {
        "mnemonic": "ld",
        "description": "Load Indirect and PostIncrement",
        "operation": [
            "Rd ← (Z)",
            "Z ← Z + 1"
        ],
        "type": "DT"
    },
    {
        "mnemonic": "ld",
        "description": "Load Indirect and PreDecrement",
        "operation": [
            "Z ← Z - 1",
            "Rd ← (Z)"
        ],
        "type": "DT"
    },
    {
        "mnemonic": "ldd",
        "description": "Load Indirect with Displacement",
        "operation": "Rd ← (Z + q)",
        "type": "DT"
    },
    {
        "mnemonic": "sts",
        "description": "Store Direct to Data Space",
        "operation": "(k) ← Rd",
        "type": "DT"
    },
    {
        "mnemonic": "st",
        "description": "Store Indirect",
        "operation": "(X) ← Rr",
        "type": "DT"
    },
    {
        "mnemonic": "st",
        "description": "Store Indirect and PostIncrement"   ,
        "operation": [
            "(X) ← Rr",
            "X ← X + 1"
        ],
        "type": "DT"
    },
    {
        "mnemonic": "st",
        "description": "Store Indirect and PreDecrement",
        "operation": [
            "X ← X - 1",
            "(X) ← Rr"
        ],
        "type": "DT"
    },
    {
        "mnemonic": "st",
        "description": "Store Indirect",
        "operation": "(Y) ← Rr",
        "type": "DT"
    },
    {
        "mnemonic": "st",
        "description": "Store Indirect and PostIncrement"   ,
        "operation": [
            "(Y) ← Rr",
            "Y ← Y + 1"
        ],
        "type": "DT"
    },
    {
        "mnemonic": "st",
        "description": "Store Indirect and PreDecrement",
        "operation": [
            "Y ← Y - 1",
            "(Y) ← Rr"
        ],
        "type": "DT"
    },
    {
        "mnemonic": "std",
        "description": "r Store Indirect with Displacement",
        "operation": "(Y + q) ← Rr",
        "type": "DT"
    },
    {
        "mnemonic": "st",
        "description": "Store Indirect",
        "operation": "(Z) ← Rr",
        "type": "DT"
    },
    {
        "mnemonic": "st",
        "description": "Store Indirect and PostIncrement"   ,
        "operation": [
            "(Z) ← Rr",
            "Z ← Z + 1"
        ],
        "type": "DT"
    },
    {
        "mnemonic": "st",
        "description": "Store Indirect and PreDecrement",
        "operation": [
            "Z ← Z - 1",
            "(Z) ← Rr"
        ],
        "type": "DT"
    },
    {
        "mnemonic": "std",
        "description": "r Store Indirect with Displacement",
        "operation": "(Z + q) ← Rr",
        "type": "DT"
    },
    {
        "mnemonic": "lpm",
        "description": "Load Program Memory",
        "operation": "R0 ← (Z)",
        "type": "DT"
    },
    {
        "mnemonic": "lpm",
        "description": "Load Program Memory",
        "operation": "Rd ← (Z)",
        "type": "DT"
    },
    {
        "mnemonic": "lpm",
        "description": "Load Program Memory and PostIncrement",
        "operation": [
            "Rd ← (Z)",
            "Z ← Z + 1"
        ],
        "type": "DT"
    },
    {
        "mnemonic": "elpm",
        "description": "Extended Load Program Memory",
        "operation": "R0 ← (RAMPZ:Z)",
        "type": "DT"
    },
    {
        "mnemonic": "elpm",
        "description": "Extended Load Program Memory",
        "operation": "Rd ← (RAMPZ:Z)",
        "type": "DT"
    },
    {
        "mnemonic": "elpm",
        "description": "Extended Load Program Memory and PostIncrement",
        "operation": [
            "Rd ← (RAMPZ:Z)",
            "(RAMPZ:Z) ← (RAMPZ:Z) + 1"
        ],
        "type": "DT"
    },
    {
        "mnemonic": "spm",
        "description": "Store Program Memory",
        "operation": "(RAMPZ:Z) ← R1:R0",
        "type": "DT"
    },
    {
        "mnemonic": "spm",
        "description": "Store Program Memory and PostIncrement by 2",
        "operation": [
            "(RAMPZ:Z) ← R1:R0",
            "Z ← Z + 2"
        ],
        "type": "DT"
    },
    {
        "mnemonic": "in",
        "description": "In From I/O Location",
        "operation": "Rd ← I/O(A)",
        "type": "DT"
    },
    {
        "mnemonic": "out",
        "description": "Out To I/O Location",
        "operation": "I/O(A) ← Rr",
        "type": "DT"
    },
    {
        "mnemonic": "push",
        "description": "Push Register on Stack",
        "operation": "STACK ← Rr",
        "type": "DT"
    },
    {
        "mnemonic": "pop",
        "description": "Pop Register from Stack",
        "operation": "Rd ← STACK",
        "type": "DT"
    },
    {
        "mnemonic": "xch",
        "description": "Exchange",
        "operation": [
            "(Z) ← Rd",
            "Rd ← (Z)"
        ],
        "type": "DT"
    },
    {
        "mnemonic": "las",
        "description": "Load and Set",
        "operation": [
            "(Z) ← Rd v (Z)",
            "Rd ← (Z)"
        ],
        "type": "DT"
    },
    {
        "mnemonic": "lac",
        "description": "Load and Clear",
        "operation": [
            "(Z) ← ($FF – Rd) • (Z)",
            "Rd ← (Z)"
        ],
        "type": "DT"
    },
    {
        "mnemonic": "lat",
        "description": "Load and Toggle",
        "operation": [
            "(Z) ← Rd ⊕ (Z)",
            "Rd ← (Z)"
        ],
        "type": "DT"
    }
]