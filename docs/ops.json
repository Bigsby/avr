[
    {
        "mnemonic": "adc",
        "name": "Add with Carry",
        "description": "Adds two registers and the contents of the C Flag and places the result in the destination register Rd.",
        "opCode": "0001 11rd dddd rrrr",
        "flags": "Z,C,N,V,S,H",
        "status": {
            "H": "Rd3 • Rr3 + Rr3 • !R3 + !R3 • Rd3",
            "S": "N ⊕ V",
            "V": "Rd7 • Rr7 • !R7 + !Rd7 • !Rr7 • R7",
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0",
            "C": "Rd7 • Rr7 + Rr7 • !R7 + !R7 • Rd7"
        },
        "operation": "Rd ← Rd + Rr + C",
        "operands": {
            "d": "0 ≤ d ≤ 31",
            "r": "0 ≤ r ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "type": "AL",
        "syntax": "ADC Rd,Rr",
        "examples": "adc r3,r1 ; Add with carry high byte"
    },
    {
        "mnemonic": "add",
        "name": "Add without Carry",
        "description": "Adds two registers without the C Flag and places the result in the destination register Rd.",
        "operation": "Rd ← Rd + Rr",
        "flags": "Z,C,N,V,S,H",
        "type": "AL",
        "operands": {
            "d": "0 ≤ d ≤ 31",
            "r": "0 ≤ r ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "syntax": "ADD Rd,Rr",
        "opCode": "0000 11rd dddd rrrr",
        "status": {
            "H": "Rd3 • Rr3 + Rr3 • !R3 + !R3 • Rd3",
            "S": "N ⊕ V",
            "V": "Rd7 • Rr7 • !R7 + !Rd7 • !Rr7 • R7"
        },
        "examples": [
            "add r1,r2 ; Add r2 to r1 (r1=r1+r2)",
            "add r28,r28 ; Add r28 to itself (r28=r28+r28)"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "adiw",
        "name": "Add Immediate to Word",
        "description": "Adds an immediate value (0 - 63) to a register pair and places the result in the register pair. This instruction operates on the upper four register pairs, and is well suited for operations on the pointer registers. This instruction is not available in all devices.",
        "operation": "Rd ← Rd + 1:Rd + K",
        "flags": "Z,C,N,V,S",
        "type": "AL",
        "syntax": "ADIW Rd+1:Rd,K",
        "operands": {
            "d": "d ∈ {24,26,28,30}",
            "K": "0 ≤ K ≤ 63"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0110 KKdd KKKK",
        "status": {
            "S": "N ⊕ V",
            "V": "!Rdh7 • R15",
            "N": "R15",
            "Z": "!R15 • !R14 • !R13 • !R12 • !R11 • !R10 • !R9 • !R8R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0",
            "C": "!R15 • Rdh7"
        },
        "examples": [
            "adiw r25:24,1 ; Add 1 to r25:r24",
            "adiw ZH:ZL,63 ; Add 63 to the Z-pointer(r31:r30)"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "sub",
        "name": "Subtract without Carry",
        "description": "Subtracts two registers and places the result in the destination register Rd.",
        "operation": "Rd ← Rd - Rr",
        "flags": "Z,C,N,V,S,H",
        "type": "AL",
        "syntax": "SUB Rd,Rr",
        "operands": {
            "d": "0 ≤ d ≤ 31",
            "r": "0 ≤ r ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0001 10rd dddd rrrr",
        "status": {
            "H": "!Rd3 • Rr3 + Rr3 • R3 + R3 • !Rd3",
            "S": "N ⊕ V",
            "V": "Rd7 • !Rr7 • !R7 + !Rd7 • Rr7 • R7",
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0",
            "C": "!Rd7 • Rr7 + Rr7 • R7 + R7 • !Rd7"
        },
        "examples": [
            "sub r13,r12 ; Subtract r12 from r13",
            "brne noteq ; Branch if r12<>r13",
            "...",
            "noteq: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "subi",
        "name": "Subtract Immediate",
        "description": "Subtracts a register and a constant, and places the result in the destination register Rd. This instruction is working on Register R16 to R31 and is very well suited for operations on the X, Y, and Z-pointers.",
        "operation": "Rd ← Rd - K",
        "flags": "Z,C,N,V,S,H",
        "type": "AL",
        "syntax": "SUBI Rd,K",
        "operands": {
            "d": "16 ≤ d ≤ 31",
            "K": "0 ≤ K ≤ 255"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0101 KKKK dddd KKKK",
        "status": {
            "H": "!Rd3 • K3 + K3 • R3 + R3 • !Rd3",
            "S": "N ⊕ V",
            "V": "Rd7 • !K7 • !R7 + !Rd7 • K7 • R7",
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0",
            "C": "!Rd7 • K7 + K7 • R7 + R7 • !Rd7"
        },
        "examples": [
            "subi r22,$11 ; Subtract $11 from r22",
            "brne noteq ; Branch if r22<>$11",
            "...",
            "noteq: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "sbc",
        "name": "Subtract with Carry",
        "description": "Subtracts two registers and subtracts with the C Flag, and places the result in the destination register Rd.",
        "operation": "Rd ← Rd - Rr - C",
        "flags": "Z,C,N,V,S,H",
        "type": "AL",
        "syntax": "SBC Rd,Rr",
        "operands": {
            "d": "0 ≤ d ≤ 31",
            "r": "0 ≤ r ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0000 10rd dddd rrrr",
        "status": {
            "H": "!Rd3 • Rr3 + Rr3 • R3 + R3 • !Rd3",
            "S": "N ⊕ V",
            "V": "Rd7 • !Rr7 • !R7 + !Rd7 • Rr7 • R7",
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0 • Z",
            "C": "!Rd7 • Rr7 + Rr7 • R7 + R7 • !Rd7"
        },
        "examples": [
            "; Subtract r1:r0 from r3:r2",
            "sub r2,r0 ; Subtract low byte",
            "sbc r3,r1 ; Subtract with carry high byte"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "sbci",
        "name": "Subtract Immediate with Carry",
        "description": "Subtracts a constant from a register and subtracts with the C Flag, and places the result in the destination register Rd.",
        "operation": "Rd ← Rd - K - C",
        "flags": "Z,C,N,V,S,H",
        "type": "AL",
        "syntax": "SBCI Rd,K",
        "operands": {
            "d": "16 ≤ d ≤ 31",
            "K": "0 ≤ K ≤ 255"
        },
        "pCounter": "PC ← PC + 1",
        "status": {
            "H": "!Rd3 • K3 + K3 • R3 + R3 • !Rd3",
            "S": "N ⊕ V",
            "V": "Rd7 • !K7 • !R7 + !Rd7 • K7 • R7",
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0 • Z",
            "C": "!Rd7 • K7 + K7 • R7 + R7 • !Rd7"
        },
        "examples": [
            "; Subtract $4F23 from r17:r16",
            "subi r16,$23 ; Subtract low byte",
            "sbci r17,$4F ; Subtract with carry high byte"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "sbiw",
        "name": "Subtract Immediate from Word",
        "description": "Subtracts an immediate value (0-63) from a register pair and places the result in the register pair. This instruction operates on the upper four register pairs, and is well suited for operations on the Pointer Registers. This instruction is not available in all devices.",
        "operation": "Rd + 1:Rd ← Rd + 1:Rd - K",
        "flags": "Z,C,N,V,S",
        "type": "AL",
        "syntax": "SBIW Rd+1:Rd,K",
        "operands": {
            "d": "d ∈ {24,26,28,30}",
            "K": "0 ≤ K ≤ 63"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0111 KKdd KKKK",
        "status": {
            "S": "N ⊕ V",
            "V": "R15 • !Rdh7",
            "N": "R15",
            "Z": "!R15 • !R14 • !R13 • !R12 • !R11 • !R10 • !R9 • !R8R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0",
            "C": "R15 • !Rdh7"
        },
        "examples": [
            "sbiw r25:r24,1 ; Subtract 1 from r25:r24",
            "sbiw YH:YL,63 ; Subtract 63 from the Y-pointer(r29:r28)"
        ],
        "words": 1,
        "cycles": 2
    },
    {
        "mnemonic": "and",
        "name": "Logical AND",
        "description": "Performs the logical AND between the contents of register Rd and register Rr, and places the result in the destination register Rd.",
        "operation": "Rd ← Rd • Rr",
        "flags": "Z,N,V,S",
        "type": "AL",
        "syntax": "AND Rd,Rr",
        "operands": {
            "d": "0 ≤ d ≤ 31",
            "r": "0 ≤ r ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0010 00rd dddd rrrr",
        "status": {
            "S": "N ⊕ V",
            "V": "0",
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0"
        },
        "examples": [
            "and r2,r3 ; Bitwise and r2 and r3, result in r2",
            "and r2,r16 ; Isolate bit 0 in r2"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "andi",
        "name": "Logical AND with Immediate",
        "description": "Performs the logical AND between the contents of register Rd and a constant, and places the result in the destination register Rd.",
        "operation": "Rd ← Rd • K",
        "flags": "Z,N,V,S",
        "type": "AL",
        "syntax": "ANDI Rd,K",
        "operands": {
            "d": "16 ≤ d ≤ 31",
            "K": "0 ≤ K ≤ 255"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0111 KKKK dddd KKKK",
        "status": {
            "S": "N ⊕ V",
            "V": "0",
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0"
        },
        "examples": [
            "andi r17,$0F ; Clear upper nibble of r17",
            "andi r18,$10 ; Isolate bit 4 in r18",
            "andi r19,$AA ; Clear odd bits of r19"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "or",
        "name": "Logical OR",
        ,
        "description": "Performs the logical OR between the contents of register Rd and register Rr, and places the result in the destination register Rd.",
        "operation": "Rd ← Rd v Rr",
        "flags": "Z,N,V,S",
        "type": "AL",
        "syntax": "OR Rd,Rr",
        "operands": {
            "d": "0 ≤ d ≤ 31",
            "r": "0 ≤ r ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0010 10rd dddd rrrr",
        "status": {
            "S": "N ⊕ V",
            "V": 0,
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0"
        },
        "examples": [
            "or r15,r16 ; Do bitwise or between registers",
            "bst r15,6 ; Store bit 6 of r15 in T Flag",
            "brts ok ; Branch if T Flag set",
            "...",
            "ok: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "ori",
        "name": "Logical OR with Immediate",
        "description": "Performs the logical OR between the contents of register Rd and a constant, and places the result in the destination register Rd.",
        "operation": "Rd v K",
        "flags": "Z,N,V,S",
        "type": "AL",
        "syntax": "ORI Rd,K",
        "operands": {
            "d": "16 ≤ d ≤ 31",
            "K": "0 ≤ K ≤ 255"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0110 KKKK dddd KKKK",
        "status": {
            "S": "N ⊕ V",
            "V": 0,
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0"
        },
        "examples": [
            "ori r16,$F0 ; Set high nibble of r16",
            "ori r17,1 ; Set bit 0 of r17"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "eor",
        "name": "Exclusive OR",
        "description": "Performs the logical EOR between the contents of register Rd and register Rr and places the result in the destination register Rd.",
        "operation": "Rd ← Rd ⊕ Rr",
        "flags": "Z,N,V,S",
        "type": "AL",
        "syntax": "EOR Rd,Rr",
        "operands": {
            "d": "0 ≤ d ≤ 31",
            "r": "0 ≤ r ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0010 01rd dddd rrrr",
        "status": {
            "S": "N ⊕ V",
            "V": 0,
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0"
        },
        "examples": [
            "eor r4,r4 ; Clear r4",
            "eor r0,r22 ; Bitwise exclusive or between r0 and r22"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "com",
        "name": "One's Complement",
        "description": "This instruction performs a One’s Complement of register Rd.",
        "operation": "Rd ← $FF - Rd",
        "flags": "Z,C,N,V,S",
        "type": "AL",
        "syntax": "COM Rd",
        "operands": {
            "d": "0 ≤ d ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "status": {
            "S": "N ⊕ V",
            "V": 0,
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0",
            "C": 1
        },
        "examples": [
            "com r4 ; Take one’s complement of r4",
            "breq zero ; Branch if zero",
            "...",
            "zero: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "neg",
        "name": "Two’s Complement",
        "description": "Replaces the contents of register Rd with its two’s complement; the value $80 is left unchanged.",
        "operation": "Rd ← $00 - Rd",
        "flags": "Z,C,N,V,S,H",
        "type": "AL",
        "syntax": "NEG Rd",
        "operands": {
            "d": "0 ≤ d ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 010d dddd 0001",
        "status": {
            "H": "Ρ3 + !Rd3",
            "S": "N ⊕ V",
            "V": "R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0",
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0",
            "C": "R7 + R6 + R5 + R4 + R3 + R2 + R1 + R0"
        },
        "examples": [
            "sub r11,r0 ; Subtract r0 from r11",
            "brpl positive ; Branch if result positive",
            "neg r11 ; Take two’s complement of r11 ",
            "positive: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "sbr",
        "name": "Set Bit(s) in Register",
        "description": "Sets specified bits in register Rd. Performs the logical ORI between the contents of register Rd and a constant mask K, and places the result in the destination register Rd.",
        "operation": "Rd ← Rd v K",
        "flags": "Z,N,V,S",
        "type": "AL",
        "syntax": "SBR Rd,K",
        "operands": {
            "d": "16 ≤ d ≤ 31",
            "K": "0 ≤ K ≤ 255"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0110 KKKK dddd KKKK",
        "status": {
            "S": "N ⊕ V",
            "V": 0,
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0"
        },
        "examples": [
            "sbr r16,3 ; Set bits 0 and 1 in r16",
            "sbr r17,$F0 ; Set 4 MSB in r17"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "cbr",
        "name": "Clear Bit(s) in Register",
        "description": "Clears the specified bits in register Rd. Performs the logical AND between the contents of register Rd and the complement of the constant mask K. The result will be placed in register Rd.",
        "operation": "Rd ← Rd • ($FFh -K)",
        "flags": "Z,N,V,S",
        "type": "AL",
        "syntax": "CBR Rd,K",
        "operands": {
            "d": "16 ≤ d ≤ 31",
            "K": "0 ≤ K ≤ 255"
        },
        "pCounter": "PC ← PC + 1",
        "status": {
            "S": "N ⊕ V",
            "V": "0",
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0"
        },
        "examples": [
            "cbr r16,$F0 ; Clear upper nibble of r16",
            "cbr r18,1 ; Clear bit 0 in r18"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "inc",
        "name": "Increment",
        "description": "Adds one -1- to the contents of register Rd and places the result in the destination register Rd. The C Flag in SREG is not affected by the operation, thus allowing the INC instruction to be used on a loop counter in multiple-precision computations. When operating on unsigned numbers, only BREQ and BRNE branches can be expected to perform consistently. When operating on two’s complement values, all signed branches are available.",
        "operation": "Rd ← Rd + 1 ",
        "flags": "Z,N,V,S",
        "type": "AL",
        "syntax": "INC Rd",
        "operands": {
            "d": "0 ≤ d ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 010d dddd 0011",
        "status": {
            "S": "N ⊕ V",
            "V": "R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0",
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0"
        },
        "examples": [
            "clr r22 ; clear r22",
            "loop: inc r22 ; increment r22",
            "...",
            "cpi r22,$4F ; Compare r22 to $4f",
            "brne loop ; Branch if not equal",
            "nop ; Continue (do nothing)"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "dec",
        "name": "Decrement",
        "description": "Subtracts one -1- from the contents of register Rd and places the result in the destination register Rd. The C Flag in SREG is not affected by the operation, thus allowing the DEC instruction to be used on a loop counter in multiple-precision computations. When operating on unsigned values, only BREQ and BRNE branches can be expected to perform consistently. When operating on two’s complement values, all signed branches are available.",
        "operation": "Rd ← Rd - 1",
        "flags": "Z,N,V,S",
        "type": "AL",
        "syntax": "DEC Rd",
        "pCounter": "PC ← PC + 1",
        "operands": {
            "d": "0 ≤ d ≤ 31"
        },
        "opCode": "1001 010d dddd 1010",
        "status": {
            "S": "N ⊕ V",
            "V": "!R7 • R6 • R5 • R4 • R3 • R2 • R1 • R0",
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0"
        },
        "examples": [
            "ldi r17,$10 ; Load constant in r17",
            "loop: add r1,r2 ; Add r2 to r1",
            "dec r17 ; Decrement r17",
            "brne loop ; Branch if r17<>0",
            "nop ; Continue (do nothing)"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "tst",
        "name": "Test for Zero or Minus",
        "description": "Tests if a register is zero or negative. Performs a logical AND between a register and itself. The register will remain unchanged.",
        "operation": "Rd ← Rd • Rd",
        "flags": "Z,N,V,S",
        "type": "AL",
        "syntax": "TST Rd",
        "operands": {
            "d": "0 ≤ d ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0010 00dd dddd dddd",
        "status": {
            "S": "N ⊕ V",
            "V": 0,
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0"
        },
        "examples": [
            "tst r0 ; Test r0",
            "breq zero ; Branch if r0=0",
            "...",
            "zero: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "clr",
        "name": "Clear Register",
        "description": "Clears a register. This instruction performs an Exclusive OR between a register and itself. This will clear all bits in the register.",
        "operation": "Rd ← Rd ⊕ Rd",
        "flags": "Z,N,V,S",
        "type": "AL",
        "syntax": "CLR Rd",
        "operands": {
            "d": "0 ≤ d ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0010 01dd dddd dddd",
        "status": {
            "S": 0,
            "V": 0,
            "N": 0,
            "Z": 1
        },
        "examples": [
            " clr r18 ; clear r18",
            "loop: inc r18 ; increase r18",
            "...",
            "cpi r18,$50 ; Compare r18 to $50",
            "brne loop"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "ser",
        "name": "Set Register",
        "description": "Loads $FF directly to register Rd",
        "operation": "Rd ← $FF",
        "flags": "",
        "type": "AL",
        "syntax": "SER Rd",
        "operands": {
            "d": "16 ≤ d ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1110 1111 dddd 1111",
        "examples": [
            "clr r16 ; Clear r16",
            "ser r17 ; Set r17",
            "out $18,r16 ; Write zeros to Port B",
            "nop ; Delay (do nothing)",
            "out $18,r17 ; Write ones to Port B"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "mul",
        "name": "Multiply Unsigned",
        "description": "This instruction performs 8-bit × 8-bit → 16-bit unsigned multiplication. The multiplicand Rd and the multiplier Rr are two registers containing unsigned numbers. The 16-bit unsigned product is placed in R1 (high byte) and R0 (low byte). Note that if the multiplicand or the multiplier is selected from R0 or R1 the result will overwrite those after multiplication. This instruction is not available in all devices.",
        "operation": "R1:R0 ← Rd x Rr (UU)",
        "flags": "Z,C",
        "type": "AL",
        "syntax": "MUL Rd,Rr",
        "operands": {
            "d": "0 ≤ d ≤ 31",
            "r": "0 ≤ r ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 11rd dddd rrrr",
        "status": {
            "C": "R15",
            "Z": "!R15 • !R14 • !R13 • !R12 • !R11 • !R10 • !R9 • !R8R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0"
        },
        "examples": [
            "mul r5,r4 ; Multiply unsigned r5 and r4",
            "mov w r4,r0 ; Copy result back in r5:r4"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "muls",
        "name": "Multiply Signed",
        "description": "This instruction performs 8-bit × 8-bit → 16-bit signed multiplication. The multiplicand Rd and the multiplier Rr are two registers containing signed numbers. The 16-bit signed product is placed in R1 (high byte) and R0 (low byte). This instruction is not available in all devices.",
        "operation": "R1:R0 ← Rd x Rr (SS)",
        "flags": "Z,C",
        "type": "AL",
        "syntax": "MULS Rd,Rr",
        "operands": {
            "d": "16 ≤ d ≤ 31",
            "r": "16 ≤ d ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0000 0010 dddd rrrr",
        "status": {
            "C": "R15",
            "Z": "!R15 • !R14 • !R13 • !R12 • !R11 • !R10 • !R9 • !R8R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0"
        },
        "examples": [
            "muls r21,r20 ; Multiply signed r21 and r20",
            "mov w r20,r0 ; Copy result back in r21:r20"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "mulsu",
        "name": "Multiply Signed with Unsigned",
        "description": "This instruction performs 8-bit × 8-bit → 16-bit multiplication of a signed and an unsigned number. The multiplicand Rd and the multiplier Rr are two registers. The multiplicand Rd is a signed number, and the multiplier Rr is unsigned. The 16-bit signed product is placed in R1 (high byte) and R0 (low byte). This instruction is not available in all devices.",
        "operation": "R1:R0 ← Rd x Rr (SU)",
        "flags": "Z,C",
        "type": "AL",
        "syntax": "MULSU Rd,Rr",
        "operands": {
            "d": "16 ≤ d ≤ 31",
            "r": "16 ≤ d ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0000 0011 0ddd 0rrr",
        "status": {
            "C": "R15",
            "Z": "!R15 • !R14 • !R13 • !R12 • !R11 • !R10 • !R9 • !R8R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0"
        },
        "examples": [
            ";******************************************************************************",
            ";* DESCRIPTION",
            ";* Signed multiply of two 16-bit numbers with 32-bit result.",
            ";* USAGE",
            ";* r19:r18:r17:r16 = r23:r22 * r21:r20",
            ";******************************************************************************",
            "muls16x16_32:",
            " clr r2",
            " muls r23, r21 ; (signed)ah * (signed)bh",
            " movw r19:r18, r1:r0",
            " mul r22, r20 ; al * bl",
            " movw r17:r16, r1:r0",
            " mulsu r23, r20 ; (signed)ah * bl",
            "Atmel AVR Instruction Set Manual [OTHER]",
            "Atmel-0856L-AVR-Instruction-Set-Manual_Other-11/2016",
            "127",
            " sbc r19, r2",
            " add r17, r0",
            " adc r18, r1",
            " adc r19, r2",
            " mulsu r21, r22 ; (signed)bh * al",
            " sbc r19, r2",
            " add r17, r0",
            " adc r18, r1",
            " adc r19, r2",
            " ret"
        ],
        "words": 1,
        "cycles": 2
    },
    {
        "mnemonic": "fmul",
        "name": "Fractional Multiply Unsigned",
        "description": "This instruction performs 8-bit × 8-bit → 16-bit unsigned multiplication and shifts the result one bit left",
        "operation": "R1:R0 ← Rd x Rr<<1 (UU)",
        "flags": "Z,C",
        "type": "AL",
        "syntax": "FMUL Rd,Rr",
        "opCode": "0000 0011 0ddd 1rrr",
        "status": {
            "C": "R16",
            "Z": "!R15 • !R14 • !R13 • !R12 • !R11 • !R10 • !R9 • !R8R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0"
        },
        "incomplete": true,
        "operands": {
            "d": "16 ≤ d ≤ 23",
            "r": "16 ≤ d ≤ 23"
        },
        "pCounter": "PC ← PC + 1",
        "words": 1,
        "cycles": 2
    },
    {
        "mnemonic": "fmuls",
        "name": "Fractional Multiply Signed",
        "description": "This instruction performs 8-bit × 8-bit → 16-bit signed multiplication and shifts the result one bit left.",
        "operation": "R1:R0 ← Rd x Rr<<1 (SS)",
        "flags": "Z,C",
        "type": "AL",
        "syntax": "FMULS Rd,Rr",
        "incomplete": true,
        "operands": {
            "d": "16 ≤ d ≤ 23",
            "r": "16 ≤ d ≤ 23"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0000 0011 1ddd 0rrr",
        "status": {
            "C": "R16",
            "Z": "!R15 • !R14 • !R13 • !R12 • !R11 • !R10 • !R9 • !R8R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0"
        },
        "examples": [
            "fmuls r23,r22 ; Multiply signed r23 and r22 in (1.7) format, result in (1.15) format",
            "mov w r23:r22,r1:r0 ; Copy result back in r23:r22"
        ],
        "words": 1,
        "cycles": 2
    },
    {
        "mnemonic": "fmulsu",
        "name": "Fractional Multiply Signed with Unsigned",
        "description": "This instruction performs 8-bit × 8-bit → 16-bit signed multiplication and shifts the result one bit left.",
        "operation": "R1:R0 ← Rd x Rr<<1 (SU)",
        "incomplete": true,
        "flags": "Z,C",
        "type": "AL",
        "syntax": "FMULSU Rd,Rr",
        "operands": {
            "d": "16 ≤ d ≤ 23",
            "r": "16 ≤ d ≤ 23"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0000 0011 1ddd 1rrr",
        "status": {
            "C": "R16",
            "Z": "!R15 • !R14 • !R13 • !R12 • !R11 • !R10 • !R9 • !R8R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0"
        },
        "words": 1,
        "cycles": 2
    },
    {
        "mnemonic": "des",
        "name": "Data Encryption",
        "description": "The module is an instruction set extension to the AVR CPU, performing DES iterations. The 64-bit data block (plaintext or ciphertext) is placed in the CPU register file, registers R0-R7, where LSB of data is placed in LSB of R0 and MSB of data is placed in MSB of R7. The full 64-bit key (including parity bits) is placed in registers R8-R15, organized in the register file with LSB of key in LSB of R8 and MSB of key in MSB of R15. Executing one DES instruction performs one round in the DES algorithm. Sixteen rounds must be executed in increasing order to form the correct DES ciphertext or plaintext. Intermediate results are stored in the register file (R0-R15) after each DES instruction. The instruction's operand (K) determines which round is executed, and the half carry flag (H) determines whether encryption or decryption is performed. The DES algorithm is described in “Specifications for the Data Encryption Standard” (Federal Information Processing Standards Publication 46). Intermediate results in this implementation differ from the standard because the initial permutation and the inverse initial permutation are performed in each iteration. This does not affect the result in the final ciphertext or plaintext, but reduces the execution time.",
        "operation": [
            "if (H = 0) then R15:R0 ← Encrypt(R15:R0, K)",
            "else if (H = 1) then R15:R0 ← Decrypt(R15:R0, K)"
        ],
        "flags": "",
        "type": "AL",
        "syntax": "DES K",
        "operands": {
            "K": "0x00 ≤ K ≤ 0x0F"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 KKKK 1011",
        "examples": [
            "DES 0x00",
            "DES 0x01",
            "...",
            "DES 0x0E",
            "DES 0x0F"
        ],
        "words": 1,
        "cycles": 1,
        "notes": "If the DES instruction is succeeding a non-DES instruction, an extra cycle is inserted."
    },
    {
        "mnemonic": "rjmp",
        "name": "Relative Jump",
        "description": "Relative jump to an address within PC - 2K +1 and PC + 2K (words). For AVR microcontrollers with Program memory not exceeding 4K words (8KB) this instruction can address the entire memory from every address location. See also JMP",
        "operation": "PC ← PC + k + 1",
        "type": "BR",
        "syntax": "RJMP",
        "operands": {
            "k": "-2K ≤ k < 2K"
        },
        "pCounter": "PC ← PC + k + 1",
        "opCode": "1100 kkkk kkkk kkkk",
        "examples": [
            "cpi r16,$42 ; Compare r16 to $42",
            "brne error ; Branch if r16 <> $42",
            "rjmp ok ; Unconditional branch",
            "error: add r16,r17 ; Add r17 to r16",
            "inc r16 ; Increment r16",
            "ok: nop ; Destination for rjmp (do nothing)"
        ],
        "words": 1,
        "cycles": 2
    },
    {
        "mnemonic": "ijmp",
        "name": "Indirect Jump to (Z)",
        "description": "Indirect jump to the address pointed to by the Z (16 bits) Pointer Register in the Register File. The Zpointer Register is 16 bits wide and allows jump within the lowest 64K words (128KB) section of Program memory. This instruction is not available in all devices.",
        "operation": [
            "PC(15:0) ← Z",
            "PC(21:16) ← 0"
        ],
        "incomplete": true,
        "type": "BR",
        "syntax": "IJMP",
        "opCode": "1001 0100 0000 1001",
        "examples": [
            "mov r30,r0 ; Set offset to jump table",
            "ijmp ; Jump to routine pointed to by r31:r30"
        ],
        "words": 1,
        "cycles": 2
    },
    {
        "mnemonic": "eijmp",
        "name": "Extended Indirect Jump to (Z)",
        "description": "ndirect jump to the address pointed to by the Z (16 bits) Pointer Register in the Register File and the EIND Register in the I/O space. This instruction allows for indirect jumps to the entire 4M (words) Program memory space. See also IJMP. This instruction is not available in all devices.",
        "operation": [
            "PC(15:0) ← Z",
            "PC(21:16) ← EIND"
        ],
        "type": "BR",
        "syntax": "EIJMP",
        "examples": [
            "ldi r16,$05 ; Set up EIND and Z-pointer",
            "out EIND,r16",
            "ldi r30,$00",
            "ldi r31,$10",
            "eijmp ; Jump to $051000"
        ],
        "words": 1,
        "cycles": 2
    },
    {
        "mnemonic": "jmp",
        "name": "Jump",
        "description": "Jump to an address within the entire 4M (words) Program memory. See also RJMP. This instruction is not available in all devices.",
        "operation": "PC ← k",
        "type": "BR",
        "syntax": "JMP k",
        "operands": {
            "k": "0 ≤ k ≤ 4M"
        },
        "opCode": [
            "1001 010k kkkk 110k",
            "kkkk kkkk kkkk kkkk"
        ],
        "examples": [
            "mov r1,r0 ; Copy r0 to r1",
            "jmp farplc ; Unconditional jump",
            "...",
            "farplc: nop ; Jump destination (do nothing)"
        ],
        "words": 2,
        "cycles": 3
    },
    {
        "mnemonic": "rcall",
        "name": "Relative Call Subroutine",
        "description": "Relative call to an address within PC - 2K + 1 and PC + 2K (words). The return address (the instruction after the RCALL) is stored onto the Stack. See also CALL. For AVR microcontrollers with Program memory not exceeding 4K words (8KB) this instruction can address the entire memory from every address location. The Stack Pointer uses a post-decrement scheme during RCALL.",
        "operation": "PC ← PC + k + 1",
        "type": "BR",
        "syntax": "RCALL k",
        "operands": {
            "k": "-2K ≤ k < 2K"
        },
        "pCounter": "PC ← PC + k + 1",
        "stack": {
            "16bit": [
                "STACK ← PC + 1",
                "SP ← SP - 2 (2 bytes,16 bits)"
            ],
            "22bit": [
                "STACK ← PC + 1",
                "SP ← SP - 3 (3 bytes, 22 bits)"
            ]
        },
        "opCode": "1101 kkkk kkkk kkkk",
        "examples": [
            "rcall routine ; Call subroutine",
            "...",
            "routine: push r14 ; Save r14 on the Stack",
            "...",
            "pop r14 ; Restore r14",
            "ret ; Return from subroutine"
        ],
        "words": 1,
        "cycles": {
            "0": {
                "16bit": 3,
                "22bit": 4
            },
            "x": {
                "16Bit": 2,
                "22bit": 3
            },
            "tiny": 4
        }
    },
    {
        "mnemonic": "icall",
        "name": "Indirect Call to (Z)",
        "description": "Calls to a subroutine within the entire 4M (words) Program memory. The return address (to the instruction after the CALL) will be stored onto the Stack. See also RCALL. The Stack Pointer uses a post-decrement scheme during CALL. This instruction is not available in all devices.",
        "operation": [
            "PC(15:0) ← Z",
            "PC(21:16) ← 0"
        ],
        "incomplete": true,
        "type": "BR",
        "syntax": "ICALL",
        "opCode": "1001 0101 0000 1001",
        "examples": [
            "mov r30,r0 ; Set offset to call table",
            "icall ; Call routine pointed to by r31:r30"
        ],
        "words": 1,
        "cycles": {
            "0": {
                "16bit": 3,
                "22bit": 4
            },
            "x": {
                "16Bit": 2,
                "22bit": 3
            }
        }
    },
    {
        "mnemonic": "eicall",
        "name": "Extended Indirect Call to (Z)",
        "description": "Indirect call of a subroutine pointed to by the Z (16 bits) Pointer Register in the Register File and the EIND Register in the I/O space. This instruction allows for indirect calls to the entire 4M (words) Program memory space. See also ICALL. The Stack Pointer uses a post-decrement scheme during EICALL. This instruction is not available in all devices.",
        "operation": [
            "PC(15:0) ← Z",
            "PC(21:16) ← EIND"
        ],
        "type": "BR",
        "syntax": "EICALL",
        "stack": [
            "STACK ← PC + 1",
            "SP ← SP - 3 (3 bytes, 22 bits)"
        ],
        "opCode": "1001 0101 0001 1001",
        "examples": [
            "ldi r16,$05 ; Set up EIND and Z-pointer",
            "out EIND,r16",
            "ldi r30,$00",
            "ldi r31,$10",
            "eicall ; Call to $051000"
        ],
        "words": 1,
        "cycles": {
            "0": 4,
            "x": 3
        },
        "notes": "only implemented in devices with 22-bit PC"
    },
    {
        "mnemonic": "call",
        "name": "Call Subroutine",
        "description": "Calls to a subroutine within the entire Program memory. The return address (to the instruction after the CALL) will be stored onto the Stack. (See also RCALL). The Stack Pointer uses a post-decrement scheme during CALL. This instruction is not available in all devices.",
        "operation": "PC ← k",
        "operations": {
            "16bitPC": {
                "operands": {
                    "k": "0 ≤ k ≤ 64K"
                },
                "stack": [
                    "STACK ← PC+2",
                    "SP ← SP-2, (2 bytes, 16 bits)"
                ]
            },
            "22bitPC": {
                "operands": {
                    "k": "0 ≤ k ≤ 4M"
                },
                "stack": [
                    "STACK ← PC+2",
                    "SP ← SP-3, (3 bytes, 22 bits)"
                ]
            }
        },
        "type": "BR",
        "syntax": "CALL k",
        "opCode": [
            "1001 010k kkkk 111k",
            "kkkk kkkk kkkk kkkk"
        ],
        "examples": [
            "mov r16,r0 ; Copy r0 to r16",
            "call check ; Call subroutine",
            "nop ; Continue (do nothing)",
            "...",
            "check: cpi r16,$42 ; Check if r16 has a special value",
            "breq error ; Branch if equal",
            "ret ; Return from subroutine",
            "...",
            "error: rjmp error ; Infinite loop"
        ],
        "words": 2,
        "cycles": {
            "0": {
                "16bit": 4,
                "22bit": 5
            },
            "x": {
                "16Bit": 3,
                "22bit": 4
            }
        }
    },
    {
        "mnemonic": "ret",
        "name": "Subroutine Return",
        "description": "Returns from subroutine. The return address is loaded from the STACK. The Stack Pointer uses a preincrement scheme during RET.",
        "operation": "PC ← STACK",
        "type": "BR",
        "syntax": "RET",
        "pCounter": {
            "15bit": "PC(15:0) ← STACK",
            "22bit": "PC(21:0) ← STACK"
        },
        "stack": {
            "16bit": "SP ← SP + 2, (2 bytes, 16 bits)",
            "22bit": "SP ← SP + 3, (3 bytes, 22 bits)"
        },
        "opCode": "1001 0101 0000 1000",
        "examples": [
            "call routine ; Call subroutine",
            "...",
            "routine: push r14 ; Save r14 on the Stack",
            "...",
            "pop r14 ; Restore r14",
            "ret ; Return from subroutine"
        ],
        "words": 1,
        "cycles": {
            "16bit": 4,
            "22bit": 5
        }
    },
    {
        "mnemonic": "reti",
        "name": "Interrupt Return",
        "description": "Returns from interrupt. The return address is loaded from the STACK and the Global Interrupt Flag is set. Note that the Status Register is not automatically stored when entering an interrupt routine, and it is not restored when returning from an interrupt routine. This must be handled by the application program. The Stack Pointer uses a pre-increment scheme during RETI.",
        "operation": {
            "16bit": "PC(15:0) ← STACK",
            "22bit": "PC(21:0) ← STACK"
        },
        "flags": "I",
        "type": "BR",
        "syntax": "RETI",
        "stack": {
            "15bit": "SP ← SP + 2 (2 bytes, 16 bits)",
            "22bit": "SP ← SP + 3 (3 bytes, 22 bits)"
        },
        "opCode": "1001 0101 0001 1000",
        "status": {
            "I": 1
        },
        "examples": [
            "...",
            "extint: push r0 ; Save r0 on the Stack",
            "...",
            "pop r0 ; Restore r0",
            "reti ; Return and enable interrupts"
        ],
        "words": 1,
        "cycles": {
            "16bit": 4,
            "22bit": 5
        },
        "notes": [
            " RETI behaves differently in megaAVR and AVR XMEGA devices. In the megaAVR series of devices, the global interrupt flag is cleared by hardware once an interrupt occurs and this bit is set when RETI is executed. In the AVR XMEGA devices, RETI will not modify the global interrupt flag in SREG since it is not cleared by hardware while entering ISR. This bit should be modified using SEI and CLI instructions when needed."
        ]
    },
    {
        "mnemonic": "cpse",
        "name": "Compare, skip if Equal",
        "description": "This instruction performs a compare between two registers Rd and Rr, and skips the next instruction if Rd = Rr.",
        "operation": "if (Rd = Rr) PC ← PC + 2 or 3 else PC ← PC + 1",
        "type": "BR",
        "syntax": "CPSE Rd,Rr",
        "operands": {
            "d": "0 ≤ d ≤ 31",
            "r": "0 ≤ r ≤ 31"
        },
        "pCounter": [
            "PC ← PC + 1, Condition false - no skip",
            "PC ← PC + 2, Skip a one word instruction",
            "PC ← PC + 3, Skip a two word instruction"
        ],
        "opCode": "0001 00rd dddd rrrr",
        "examples": [
            "inc r4 ; Increase r4",
            "cpse r4,r0 ; Compare r4 to r0",
            "neg r4 ; Only executed if r4<>r0",
            "nop ; Continue (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false (no skip)",
            "2 if condition is true (skip is executed) and the instruction skipped is 1 word",
            "3 if condition is true (skip is executed) and the instruction skipped is 2 words"
        ]
    },
    {
        "mnemonic": "cp",
        "name": "Compare",
        "description": "This instruction performs a compare between two registers Rd and Rr. None of the registers are changed. All conditional branches can be used after this instruction.",
        "operation": "Rd - Rr",
        "flags": "Z,C,N,V,S,H",
        "type": "BR",
        "syntax": "CP Rd,Rr",
        "operands": {
            "d": "0 ≤ d ≤ 31",
            "r": "0 ≤ r ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0001 01rd dddd rrrr",
        "status": {
            "H": "!Rd3 • Rr3 + Rr3 • R3 + R3 • !Rd3",
            "S": "N ⊕ V",
            "V": "Rd7 • Rr7 • !R7 + !Rd7 • !Rr7 • R7",
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0",
            "C": "!Rd7 • Rr7 + Rr7 • R7 + R7 • !Rd7"
        },
        "examples": [
            "cp r4,r19 ; Compare r4 with r19",
            "brne noteq ; Branch if r4 <> r19",
            "...",
            "noteq: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "cpc",
        "name": "Compare with Carry",
        "description": "This instruction performs a compare between two registers Rd and Rr and also takes into account the previous carry. None of the registers are changed. All conditional branches can be used after this instruction.",
        "operation": "Rd - Rr - C",
        "flags": "Z,C,N,V,S,H",
        "type": "BR",
        "syntax": "CPC Rd,Rr",
        "operands": {
            "d": "0 ≤ d ≤ 31",
            "r": "0 ≤ r ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0000 01rd dddd rrrr",
        "status": {
            "H": "!Rd3 • Rr3 + Rr3 • R3 + R3 • !Rd3",
            "S": "N ⊕ V",
            "V": "Rd7 • !Rr7 • !R7 + !Rd7 • Rr7 • R7",
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0",
            "C": "!Rd7 • Rr7 + Rr7 • R7 + R7 • !Rd7"
        },
        "examples": [
            "; Compare r3:r2 with r1:r0",
            "cp r2,r0 ; Compare low byte",
            "cpc r3,r1 ; Compare high byte",
            "brne noteq ; Branch if not equal",
            "...",
            "noteq: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "cpi",
        "name": "Compare with Immediate",
        "description": "This instruction performs a compare between register Rd and a constant. The register is not changed. All conditional branches can be used after this instruction.",
        "operation": "Rd - K",
        "flags": "Z,C,N,V,S,H",
        "type": "BR",
        "syntax": "CPI Rd,K",
        "operands": {
            "d": "16 ≤ d ≤ 31",
            "K": "0 ≤ K ≤ 255"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0011 KKKK dddd KKKK",
        "status": {
            "H": "!Rd3 • K3 + K3 • R3 + R3 • !Rd3",
            "S": "N ⊕ V",
            "V": "Rd7 • !K7 • !R7 + !Rd7 • K7 • R7",
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0",
            "C": "!Rd7 • K7 + K7 • R7 + R7 • !Rd7"
        },
        "examples": [
            "cpi r19,3 ; Compare r19 with 3",
            "brne error ; Branch if r19<>3",
            "...",
            "error: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "sbrc",
        "name": "Skip if Bit in Register Cleared",
        "description": "This instruction tests a single bit in a register and skips the next instruction if the bit is cleared",
        "operation": "if (Rr(b) = 0) PC ← PC + 2 or 3 else PC ← PC + 1",
        "type": "BR",
        "syntax": "SBRC Rr,b",
        "operands": {
            "r": "0 ≤ r ≤ 31",
            "b": "0 ≤ b ≤ 7"
        },
        "pCounter": [
            "PC ← PC + 1, Condition false - no skip",
            "PC ← PC + 2, Skip a one word instruction",
            "PC ← PC + 3, Skip a two word instruction"
        ],
        "opCode": "1111 110r rrrr 0bbb",
        "examples": [
            "sub r0,r1 ; Subtract r1 from r0",
            "sbrc r0,7 ; Skip if bit 7 in r0 cleared",
            "sub r0,r1 ; Only executed if bit 7 in r0 not cleared",
            "nop ; Continue (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false (no skip)",
            "2 if condition is true (skip is executed) and the instruction skipped is 1 word",
            "3 if condition is true (skip is executed) and the instruction skipped is 2 words"
        ]
    },
    {
        "mnemonic": "sbrs",
        "name": "Skip if Bit in Register Set",
        "description": "This instruction tests a single bit in a register and skips the next instruction if the bit is set.",
        "operation": "if (Rr(b) = 1) PC ← PC + 2 or 3 else PC ← PC + 1",
        "type": "BR",
        "syntax": "SBRS Rr,b",
        "operands": {
            "r": "0 ≤ r ≤ 31",
            "b": "0 ≤ b ≤ 7"
        },
        "pCounter": [
            "PC ← PC + 1, Condition false - no skip",
            "PC ← PC + 2, Skip a one word instruction",
            "PC ← PC + 3, Skip a two word instruction"
        ],
        "opCode": "1111 111r rrrr 0bbb",
        "examples": [
            "sub r0,r1 ; Subtract r1 from r0",
            "sbrs r0,7 ; Skip if bit 7 in r0 set",
            "neg r0 ; Only executed if bit 7 in r0 not set",
            "nop ; Continue (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false (no skip)",
            "2 if condition is true (skip is executed) and the instruction skipped is 1 word",
            "3 if condition is true (skip is executed) and the instruction skipped is 2 words"
        ]
    },
    {
        "mnemonic": "sbic",
        "name": "Skip if Bit in I/O Register Cleared",
        "description": "This instruction tests a single bit in an I/O Register and skips the next instruction if the bit is cleared. This instruction operates on the lower 32 I/O Registers – addresses 0-31.",
        "operation": "if (I/O(A,b) = 0) PC ← PC + 2 or 3 else PC ← PC + 1",
        "type": "BR",
        "syntax": "SBIC A,b",
        "operands": {
            "A": "0 ≤ A ≤ 31",
            "b": "0 ≤ b ≤ 7"
        },
        "pCounter": [
            "PC ← PC + 1, Condition false - no skip",
            "PC ← PC + 2, Skip a one word instruction",
            "PC ← PC + 3, Skip a two word instruction"
        ],
        "opCode": "1001 1001 AAAA Abbb",
        "examples": [
            "e2wait: sbic $1C,1 ; Skip next inst. if EEWE cleared",
            "rjmp e2wait ; EEPROM write not finished",
            "nop ; Continue (do nothing)"
        ],
        "words": 1,
        "cycles": {
            "0": [
                "1 if condition is false (no skip)",
                "2 if condition is true (skip is executed) and the instruction skipped is 1 word",
                "3 if condition is true (skip is executed) and the instruction skipped is 2 words"
            ],
            "x": [
                "2 if condition is false (no skip)",
                "3 if condition is true (skip is executed) and the instruction skipped is 1 word",
                "4 if condition is true (skip is executed) and the instruction skipped is 2 words"
            ]
        }
    },
    {
        "mnemonic": "sbis",
        "name": "Skip if Bit in I/O Register Set",
        "description": "This instruction tests a single bit in an I/O Register and skips the next instruction if the bit is set. This instruction operates on the lower 32 I/O Registers – addresses 0-31.",
        "operation": "If (I/O(A,b) =1) PC ← PC + 2 or 3 else PC ← PC + 1",
        "type": "BR",
        "syntax": "SBIS A,b",
        "operands": {
            "A": "0 ≤ A ≤ 31",
            "b": "0 ≤ b ≤ 7"
        },
        "pCounter": [
            "PC ← PC + 1, Condition false - no skip",
            "PC ← PC + 2, Skip a one word instruction",
            "PC ← PC + 3, Skip a two word instruction"
        ],
        "opCode": "1001 1011 AAAA Abbb",
        "examples": [
            "waitset: sbis $10,0 ; Skip next inst. if bit 0 in Port D set",
            "rjmp waitset ; Bit not set",
            "nop ; Continue (do nothing)"
        ],
        "words": 1,
        "cycles": {
            "0": [
                "1 if condition is false (no skip)",
                "2 if condition is true (skip is executed) and the instruction skipped is 1 word",
                "3 if condition is true (skip is executed) and the instruction skipped is 2 words"
            ],
            "x": [
                "2 if condition is false (no skip)",
                "3 if condition is true (skip is executed) and the instruction skipped is 1 word",
                "4 if condition is true (skip is executed) and the instruction skipped is 2 words"
            ]
        }
    },
    {
        "mnemonic": "brbs",
        "name": "Branch if Status Flag Set",
        "description": "Conditional relative branch. Tests a single bit in SREG and branches relatively to PC if the bit is set. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form.",
        "operation": "if (SREG(s) = 1) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRBS s,k",
        "operands": {
            "s": "0 ≤ s ≤ 7",
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 00kk kkkk ksss",
        "examples": [
            "bst r0,3 ; Load T bit with bit 3 of r0",
            "brbs 6,bitset ; Branch T bit was set",
            "...",
            "bitset: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brbc",
        "name": "Branch if Status Flag Cleared",
        "description": "Conditional relative branch. Tests a single bit in SREG and branches relatively to PC if the bit is cleared. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form.",
        "operation": "if (SREG(s) = 0) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRBC s,k",
        "operands": {
            "s": "0 ≤ s ≤ 7",
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 01kk kkkk ksss",
        "examples": [
            "cpi r20,5 ; Compare r20 to the value 5",
            "brbc 1,noteq ; Branch if Zero Flag cleared",
            "...",
            "noteq: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "breq",
        "name": "Branch if Equal",
        "description": "Conditional relative branch. Tests the Zero Flag (Z) and branches relatively to PC if Z is set. If the instruction is executed immediately after any of the instructions CP, CPI, SUB, or SUBI, the branch will occur if and only if the unsigned or signed binary number represented in Rd was equal to the unsigned or signed binary number represented in Rr. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBS 1,k.)",
        "operation": "if (Z = 1) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BREQ k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 00kk kkkk k001",
        "examples": [
            "cp r1,r0 ; Compare registers r1 and r0",
            "breq equal ; Branch if registers equal",
            "...",
            "equal: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brne",
        "name": "Branch if Not Equal",
        "description": "Conditional relative branch. Tests the Zero Flag (Z) and branches relatively to PC if Z is cleared. If the instruction is executed immediately after any of the instructions CP, CPI, SUB, or SUBI, the branch will occur if and only if, the unsigned or signed binary number represented in Rd was not equal to the unsigned or signed binary number represented in Rr. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBC 1,k.)",
        "operation": "if (Z = 0) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRNE k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 01kk kkkk k001",
        "examples": [
            "eor r27,r27 ; Clear r27",
            "loop: inc r27 ; Increase r27",
            "...",
            "cpi r27,5 ; Compare r27 to 5",
            "brne loop ; Branch if r27<>5",
            "nop ; Loop exit (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brcs",
        "name": "Branch if Carry Set",
        "description": "Conditional relative branch. Tests the Carry Flag (C) and branches relatively to PC if C is set. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBS 0,k.)",
        "operation": "if (C = 1) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRCS k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 00kk kkkk k000",
        "examples": [
            "cpi r26,$56 ; Compare r26 with $56",
            "brcs carry ; Branch if carry set",
            "...",
            "carry: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brcc",
        "name": "Branch if Carry Cleared",
        "description": "Conditional relative branch. Tests the Carry Flag (C) and branches relatively to PC if C is cleared. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBC 0,k.)",
        "operation": "if (C = 0) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRCC k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 01kk kkkk k000",
        "examples": [
            "add r22,r23 ; Add r23 to r22",
            "brcc nocarry ; Branch if carry cleared",
            "...",
            "nocarry: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brsh",
        "name": "Branch if Same or Higher",
        "description": "Conditional relative branch. Tests the Carry Flag (C) and branches relatively to PC if C is cleared. If the instruction is executed immediately after execution of any of the instructions CP, CPI, SUB, or SUBI, the branch will occur if and only if, the unsigned binary number represented in Rd was greater than or equal to the unsigned binary number represented in Rr. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBC 0,k.)",
        "operation": "if (C = 0) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRSH k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 01kk kkkk k000",
        "examples": [
            "subi r19,4 ; Subtract 4 from r19",
            "brsh highsm ; Branch if r19 >= 4 (unsigned)",
            "...",
            "highsm: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brlo",
        "name": "Branch if Lower",
        "description": "Conditional relative branch. Tests the Carry Flag (C) and branches relatively to PC if C is set. If the instruction is executed immediately after any of the instructions CP, CPI, SUB, or SUBI, the branch will occur if and only if, the unsigned binary number represented in Rd was smaller than the unsigned binary number represented in Rr. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBS 0,k.)",
        "operation": "if (C = 1) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRLO k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 00kk kkkk k000",
        "examples": [
            "eor r19,r19 ; Clear r19",
            "loop: inc r19 ; Increase r19",
            "...",
            "cpi r19,$10 ; Compare r19 with $10",
            "brlo loop ; Branch if r19 < $10 (unsigned)",
            "nop ; Exit from loop (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brmi",
        "name": "Branch if Minus",
        "description": "Conditional relative branch. Tests the Negative Flag (N) and branches relatively to PC if N is set. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBS 2,k.)",
        "operation": "if (N = 1) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRMI k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 00kk kkkk k010",
        "examples": [
            "subi r18,4 ; Subtract 4 from r18",
            "brmi negative ; Branch if result negative",
            "...",
            "negative: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brpl",
        "name": "Branch if Plus",
        "description": "Conditional relative branch. Tests the Negative Flag (N) and branches relatively to PC if N is cleared. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBC 2,k.)",
        "operation": "if (N = 0) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRPL k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 01kk kkkk k010",
        "examples": [
            "subi r26,$50 ; Subtract $50 from r26",
            "brpl positive ; Branch if r26 positive",
            "...",
            "positive: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brge",
        "name": "Branch if Greater or Equal, Signed",
        "description": "Conditional relative branch. Tests the Signed Flag (S) and branches relatively to PC if S is cleared. If the instruction is executed immediately after any of the instructions CP, CPI, SUB, or SUBI, the branch will occur if and only if the signed binary number represented in Rd was greater than or equal to the signed binary number represented in Rr. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBC 4,k.)",
        "operation": "if (N ⊕ V= 0) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRGE k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 01kk kkkk k100",
        "examples": [
            "cp r11,r12 ; Compare registers r11 and r12",
            "brge greateq ; Branch if r11 ≥ r12 (signed)",
            "...",
            "greateq: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brlt",
        "name": "Branch if Less Than, Signed",
        "description": "Conditional relative branch. Tests the Signed Flag (S) and branches relatively to PC if S is set. If the instruction is executed immediately after any of the instructions CP, CPI, SUB, or SUBI, the branch will occur if and only if, the signed binary number represented in Rd was less than the signed binary number represented in Rr. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBS 4,k.)",
        "operation": "if (N ⊕ V= 1) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRLT k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 00kk kkkk k100",
        "examples": [
            "cp r16,r1 ; Compare r16 to r1",
            "brlt less ; Branch if r16 < r1 (signed)",
            "...",
            "less: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brhs",
        "name": "Branch if Half Carry Flag Set",
        "description": "Conditional relative branch. Tests the Half Carry Flag (H) and branches relatively to PC if H is set. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBS 5,k.)",
        "operation": "if (H = 1) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRHS k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 00kk kkkk k101",
        "examples": [
            "brhs hset ; Branch if Half Carry Flag set",
            "...",
            "hset: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brhc",
        "name": "Branch if Half Carry Flag Cleared",
        "description": "Conditional relative branch. Tests the Half Carry Flag (H) and branches relatively to PC if H is cleared. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBC 5,k.)",
        "operation": "if (H = 0) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRHC k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 01kk kkkk k101",
        "examples": [
            "brhc hclear ; Branch if Half Carry Flag cleared",
            "...",
            "hclear: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brts",
        "name": "Branch if T Flag Set",
        "description": "Conditional relative branch. Tests the T Flag and branches relatively to PC if T is set. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBS 6,k.)",
        "operation": "if (T = 1) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRTS k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 00kk kkkk k110",
        "examples": [
            "bst r3,5 ; Store bit 5 of r3 in T Flag",
            "brts tset ; Branch if this bit was set",
            "...",
            "tset: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brtc",
        "name": "Branch if T Flag Cleared",
        "description": "Conditional relative branch. Tests the T Flag and branches relatively to PC if T is cleared. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBC 6,k.)",
        "operation": "if (T = 0) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRTC k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 01kk kkkk k110",
        "examples": [
            "bst r3,5 ; Store bit 5 of r3 in T Flag",
            "brtc tclear ; Branch if this bit was cleared",
            "...",
            "tclear: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brvs",
        "name": "Branch if Overflow Flag is Set",
        "description": "Conditional relative branch. Tests the Overflow Flag (V) and branches relatively to PC if V is set. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBS 3,k.)",
        "operation": "if (V = 1) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRVS k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 00kk kkkk k011",
        "examples": [
            "add r3,r4 ; Add r4 to r3",
            "brvs overfl ; Branch if overflow",
            "...",
            "overfl: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brvc",
        "name": "Branch if Overflow Flag is Cleared",
        "description": "Conditional relative branch. Tests the Overflow Flag (V) and branches relatively to PC if V is cleared. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBC 3,k.)",
        "operation": "if (V = 0) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRVC k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 01kk kkkk k011",
        "examples": [
            "add r3,r4 ; Add r4 to r3",
            "brvc noover ; Branch if no overflow",
            "...",
            "noover: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brie",
        "name": "Branch if Interrupt Enabled",
        "description": "Conditional relative branch. Tests the Global Interrupt Flag (I) and branches relatively to PC if I is set. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBS 7,k.)",
        "operation": "if (I = 1) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRIE k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 00kk kkkk k111",
        "examples": [
            "brie inten ; Branch if interrupt enabled",
            "...",
            "inten: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brid",
        "name": "Branch if Interrupt Disabled",
        "description": "Conditional relative branch. Tests the Global Interrupt Flag (I) and branches relatively to PC if I is cleared. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBC 7,k.)",
        "operation": "if (I = 0) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRID k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 01kk kkkk k111",
        "examples": [
            "brid intdis ; Branch if interrupt disabled",
            "...",
            "intdis: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "mov",
        "name": "Copy Register",
        "description": "This instruction makes a copy of one register into another. The source register Rr is left unchanged, while the destination register Rd is loaded with a copy of Rr.",
        "operation": "Rd ← Rr",
        "type": "DT",
        "syntax": "MOV Rd,Rr",
        "operands": {
            "d": "0 ≤ d ≤ 31",
            "r": "0 ≤ r ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0010 11rd dddd rrrr",
        "examples": [
            "mov r16,r0 ; Copy r0 to r16",
            "call check ; Call subroutine",
            "...",
            "check: cpi r16,$11 ; Compare r16 to $11",
            "...",
            "ret ; Return from subroutine"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "movw",
        "name": "Copy Register Pair",
        "description": "This instruction makes a copy of one register pair into another register pair. The source register pair Rr +1:Rr is left unchanged, while the destination register pair Rd+1:Rd is loaded with a copy of Rr + 1:Rr. This instruction is not available in all devices.",
        "operation": "Rd+1:Rd ← Rr+1:Rr",
        "type": "DT",
        "syntax": "MOVW Rd+1:Rd,Rr+1:Rr",
        "operands": {
            "d": "d ∈ {0,2,...,30}",
            "r": "r ∈ {0,2,...,30}"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0000 0001 dddd rrrr",
        "examples": [
            "mov w r17:16,r1:r0 ; Copy r1:r0 to r17:r16",
            "call check ; Call subroutine",
            "...",
            "check: cpi r16,$11 ; Compare r16 to $11",
            "...",
            "cpi r17,$32 ; Compare r17 to $32",
            "...",
            "ret ; Return from subroutine"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "ldi",
        "name": "Load Immediate",
        "description": "Loads an 8-bit constant directly to register 16 to 31.",
        "operation": "Rd ← K",
        "type": "DT",
        "syntax": "LDI Rd,K",
        "operands": {
            "d": "16 ≤ d ≤ 31",
            "K": "0 ≤ K ≤ 255"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1110 KKKK dddd KKKK",
        "examples": [
            "clr r31 ; Clear Z high byte",
            "ldi r30,$F0 ; Set Z low byte to $F0",
            "lpm ; Load constant from Program",
            "; memory pointed to by Z"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "lds",
        "name": "Load Direct from data space",
        "description": "Loads one byte from the data space to a register. For parts with SRAM, the data space consists of the Register File, I/O memory, and internal SRAM (and external SRAM if applicable). For parts without SRAM, the data space consists of the register file only. The EEPROM has a separate address space. A 16-bit address must be supplied. Memory access is limited to the current data segment of 64KB. The LDS instruction uses the RAMPD Register to access memory above 64KB. To access another data segment in devices with more than 64KB data space, the RAMPD in register in the I/O area has to be changed. This instruction is not available in all devices.",
        "operation": "Rd ← (k)",
        "type": "DT",
        "syntax": "LDS Rd,k",
        "operands": {
            "d": "0 ≤ d ≤ 31",
            "k": "0 ≤ k ≤ 65535"
        },
        "pCounter": "PC ← PC + 2",
        "opCode": [
            "1001 000d dddd 0000",
            "kkkk kkkk kkkk kkkk"
        ],
        "examples": [
            "lds r2,$FF00 ; Load r2 with the contents of data space location $FF00",
            "add r2,r1 ; add r1 to r2",
            "sts $FF00,r2 ; Write back"
        ],
        "words": 2,
        "cycles": {
            "0": 2,
            "x": 2
        },
        "notes": "Cycles XMEGA. If the LDS instruction is accessing internal SRAM, one extra cycle is inserted",
        "incomplete": true
    },
    {
        "mnemonic": "ld",
        "name": "Load Indirect using Index X",
        "operation": "Rd ← (X)",
        "type": "DT",
        "incomplete": true,
        "opCode": "1001 000d dddd 1100"
    },
    {
        "mnemonic": "ld",
        "name": "Load Indirect and PostIncrement using Index X",
        "operation": [
            "Rd ← (X)",
            "X ← X + 1"
        ],
        "type": "DT",
        "incomplete": true,
        "opCode": "1001 000d dddd 1101"
    },
    {
        "mnemonic": "ld",
        "name": "Load Indirect and PreDecrement using Index X",
        "operation": [
            "X ← X - 1",
            "Rd ← (X)"
        ],
        "type": "DT",
        "incomplete": true,
        "opCode": "1001 000d dddd 1110"
    },
    {
        "mnemonic": "ld",
        "name": "Load Indirect using Index Y",
        "operation": "Rd ← (Y)",
        "type": "DT",
        "incomplete": true,
        "opCode": "1000 000d dddd 1000"
    },
    {
        "mnemonic": "ld",
        "name": "Load Indirect and PostIncrement using Index Y",
        "operation": [
            "Rd ← (Y)",
            "Y ← Y + 1"
        ],
        "type": "DT",
        "incomplete": true,
        "opCode": "1001 000d dddd 1001"
    },
    {
        "mnemonic": "ld",
        "name": "Load Indirect and PreDecrement using Index Y",
        "operation": [
            "Y ← Y - 1",
            "Rd ← (Y)"
        ],
        "type": "DT",
        "incomplete": true,
        "opCode": "1001 000d dddd 1010"
    },
    {
        "mnemonic": "ldd",
        "description": "Load Indirect with Displacement using Index Y",
        "operation": "Rd ← (Y + q)",
        "type": "DT",
        "incomplete": true,
        "opCode": "10q0 qq0d dddd 1qqq"
    },
    {
        "mnemonic": "ld",
        "name": "Load Indirect using Index Z",
        "operation": "Rd ← (Z)",
        "type": "DT",
        "incomplete": true,
        "opCode": "1000 000d dddd 0000"
    },
    {
        "mnemonic": "ld",
        "name": "Load Indirect and PostIncrement using Index Z",
        "operation": [
            "Rd ← (Z)",
            "Z ← Z + 1"
        ],
        "type": "DT",
        "incomplete": true,
        "opCode": "1001 000d dddd 0001"
    },
    {
        "mnemonic": "ld",
        "name": "Load Indirect and PreDecrement using Index Z",
        "operation": [
            "Z ← Z - 1",
            "Rd ← (Z)"
        ],
        "type": "DT",
        "incomplete": true,
        "opCode": "1001 000d dddd 0010"
    },
    {
        "mnemonic": "ldd",
        "description": "Load Indirect with Displacement using Index Z",
        "operation": "Rd ← (Z + q)",
        "type": "DT",
        "incomplete": true,
        "opCode": "10q0 qq0d dddd 0qqq"
    },
    {
        "mnemonic": "sts",
        "name": "Store Direct to Data Space",
        "description": "Stores one byte from a Register to the data space. For parts with SRAM, the data space consists of the Register File, I/O memory, and internal SRAM (and external SRAM if applicable). For parts without SRAM, the data space consists of the Register File only. The EEPROM has a separate address space. A 16-bit address must be supplied. Memory access is limited to the current data segment of 64KB. The STS instruction uses the RAMPD Register to access memory above 64KB. To access another data segment in devices with more than 64KB data space, the RAMPD in register in the I/O area has to be changed. This instruction is not available in all devices.",
        "operation": "(k) ← Rd",
        "type": "DT",
        "syntax": "STS k,Rr",
        "operands": {
            "r": "0 ≤ r ≤ 31",
            "k": "0 ≤ k ≤ 65535"
        },
        "pCounter": "PC ← PC + 2",
        "error": true,
        "opCode": [
            "1001 001d dddd 0000",
            "kkkk kkkk kkkk kkkk"
        ],
        "examples": [
            "lds r2,$FF00 ; Load r2 with the contents of data space location $FF00",
            "add r2,r1 ; add r1 to r2",
            "sts $FF00,r2 ; Write back"
        ],
        "words": 2,
        "cycles": 2,
        "16bit": {
            "operands": {
                "r": "16 ≤ d ≤ 31",
                "k": "0 ≤ k ≤ 65535"
            },
            "opCode": "1010 1kkk dddd kkkk",
            "examples": [
                "lds r16,$00 ; Load r16 with the contents of data space location $00",
                "add r16,r17 ; add r17 to r16",
                "sts $00,r16 ; Write result to the same address it was fetched from"
            ],
            "words": 1,
            "cycles": 1,
            "notes": [
                "Registers r0...r15 are remapped to r16...r31"
            ]
        }
    },
    {
        "mnemonic": "st",
        "description": "Store Indirect using Index X",
        "operation": "(X) ← Rr",
        "type": "DT",
        "incomplete": true,
        "opCode": "1001 001r rrrr 1100"
    },
    {
        "mnemonic": "st",
        "description": "Store Indirect and PostIncrement using Index X",
        "operation": [
            "(X) ← Rr",
            "X ← X + 1"
        ],
        "type": "DT",
        "incomplete": true,
        "opCode": "1001 001r rrrr 1101"
    },
    {
        "mnemonic": "st",
        "description": "Store Indirect and PreDecrement using Index X",
        "operation": [
            "X ← X - 1",
            "(X) ← Rr"
        ],
        "type": "DT",
        "incomplete": true,
        "opCode": "1001 001r rrrr 1110"
    },
    {
        "mnemonic": "st",
        "description": "Store Indirect using Index Y",
        "operation": "(Y) ← Rr",
        "type": "DT",
        "incomplete": true,
        "opCode": "1000 001r rrrr 1000"
    },
    {
        "mnemonic": "st",
        "description": "Store Indirect and PostIncrement using Index Y",
        "operation": [
            "(Y) ← Rr",
            "Y ← Y + 1"
        ],
        "type": "DT",
        "incomplete": true,
        "opCode": "1001 001r rrrr 1001"
    },
    {
        "mnemonic": "st",
        "description": "Store Indirect and PreDecrement using Index Y",
        "operation": [
            "Y ← Y - 1",
            "(Y) ← Rr"
        ],
        "type": "DT",
        "incomplete": true,
        "opCode": "1001 001r rrrr 1010"
    },
    {
        "mnemonic": "std",
        "description": "r Store Indirect with Displacement using Index Y",
        "operation": "(Y + q) ← Rr",
        "type": "DT",
        "incomplete": true,
        "opCode": "10q0 qq1r rrrr 1qqq"
    },
    {
        "mnemonic": "st",
        "description": "Store Indirect using Index Z",
        "operation": "(Z) ← Rr",
        "type": "DT",
        "incomplete": true,
        "opCode": "1000 001r rrrr 0000"
    },
    {
        "mnemonic": "st",
        "description": "Store Indirect and PostIncrement using Index Z",
        "operation": [
            "(Z) ← Rr",
            "Z ← Z + 1"
        ],
        "type": "DT",
        "incomplete": true,
        "opCode": "1001 001r rrrr 0001"
    },
    {
        "mnemonic": "st",
        "description": "Store Indirect and PreDecrement using Index Z",
        "operation": [
            "Z ← Z - 1",
            "(Z) ← Rr"
        ],
        "type": "DT",
        "incomplete": true,
        "opCode": "1001 001r rrrr 0010"
    },
    {
        "mnemonic": "std",
        "description": "r Store Indirect with Displacement using Index Z",
        "operation": "(Z + q) ← Rr",
        "type": "DT",
        "incomplete": true,
        "opCode": "10q0 qq1r rrrr 0qqq"
    },
    {
        "mnemonic": "lpm",
        "name": "Load Program Memory",
        "description": "Loads one byte pointed to by the Z-register into the destination register Rd. This instruction features a 100% space effective constant initialization or constant data fetch. The Program memory is organized in 16-bit words while the Z-pointer is a byte address. Thus, the least significant bit of the Z-pointer selects either low byte (ZLSB = 0) or high byte (ZLSB = 1). This instruction can address the first 64KB (32K words) of Program memory. The Z-pointer Register can either be left unchanged by the operation, or it can be incremented. The incrementation does not apply to the RAMPZ Register. Devices with Self-Programming capability can use the LPM instruction to read the Fuse and Lock bit values. Refer to the device documentation for a detailed description. The LPM instruction is not available in all devices",
        "operation": "R0 ← (Z)",
        "type": "DT",
        "notes": [
            "The result of these combinations is undefined:",
            "LPM r30, Z+",
            "LPM r31, Z+"
        ],
        "syntax": "LPM",
        "opCode": "1001 0101 1100 1000",
        "words": 1,
        "cycles": 3,
        "incomplete": true
    },
    {
        "mnemonic": "lpm",
        "description": "Load Program Memory",
        "operation": "Rd ← (Z)",
        "type": "DT",
        "syntax": "LPM Rd, Z",
        "opCode": "1001 000d dddd 0100",
        "words": 1,
        "cycles": 3,
        "incomplete": true
    },
    {
        "mnemonic": "lpm",
        "description": "Load Program Memory and PostIncrement",
        "operation": [
            "Rd ← (Z)",
            "Z ← Z + 1"
        ],
        "type": "DT",
        "syntax": "LPM Rd, Z+",
        "opCode": "1001 000d dddd 0101",
        "words": 1,
        "cycles": 3,
        "incomplete": true
    },
    {
        "mnemonic": "elpm",
        "description": "Loads one byte pointed to by the Z-register and the RAMPZ Register in the I/O space, and places this byte in the destination register Rd. This instruction features a 100% space effective constant initialization or constant data fetch. The Program memory is organized in 16-bit words while the Z-pointer is a byte address. Thus, the least significant bit of the Z-pointer selects either low byte (ZLSB = 0) or high byte (ZLSB = 1). This instruction can address the entire Program memory space. The Z-pointer Register can either be left unchanged by the operation, or it can be incremented. The incrementation applies to the entire 24-bit concatenation of the RAMPZ and Z-pointer Registers. Devices with Self-Programming capability can use the ELPM instruction to read the Fuse and Lock bit value. Refer to the device documentation for a detailed description. This instruction is not available in all devices.",
        "operations": [
            {
                "name": "Extended Load Program Memory",
                "syntax": "ELPM",
                "operation": "R0 ← (RAMPZ:Z)",
                "opCode": "1001 0101 1101 1000"
            },
            {
                "name": "Extended Load Program Memory",
                "syntax": "ELPM Rd, Z",
                "operands": {
                    "d": "0 ≤ d ≤ 31"
                },
                "opCode": "1001 000d dddd 0110"
            },
            {
                "name": "Extended Load Program Memory and PostIncrement",
                "operation": [
                    "Rd ← (RAMPZ:Z)",
                    "(RAMPZ:Z) ← (RAMPZ:Z) + 1"
                ],
                "syntax": "ELPM Rd, Z+",
                "operands": {
                    "d": "0 ≤ d ≤ 31"
                },
                "opCode": "1001 000d dddd 0111"
            }
        ],
        "pCounter": "PC ← PC + 1",
        "type": "DT",
        "notes": [
            "The result of these combinations is undefined:",
            "ELPM r30, Z+",
            "ELPM r31, Z+"
        ],
        "examples": [
            "ldi ZL, byte3(Table_1<<1) ; Initialize Z-pointer",
            "out RAMPZ, ZL",
            "ldi ZH, byte2(Table_1<<1)",
            "ldi ZL, byte1(Table_1<<1)",
            "elpm r16, Z+ ; Load constant from Program",
            "; memory pointed to by RAMPZ:Z (Z is r31:r30)",
            "...",
            "Table_1:",
            ".dw 0x3738 ; 0x38 is addressed when ZLSB = 0",
            "; 0x37 is  addressed when ZLSB = 1"
        ]
    },
    {
        "mnemonic": "spm",
        "name": "Store Program Memory",
        "description": "SPM can be used to erase a page in the Program memory, to write a page in the Program memory (that is already erased), and to set Boot Loader Lock bits. In some devices, the Program memory can be written one word at a time, in other devices an entire page can be programmed simultaneously after first filling a temporary page buffer. In all cases, the Program memory must be erased one page at a time. When erasing the Program memory, the RAMPZ and Z-register are used as page address. When writing the Program memory, the RAMPZ and Z-register are used as page or word address, and the R1:R0 register pair is used as data(1). When setting the Boot Loader Lock bits, the R1:R0 register pair is used as data. Refer to the device documentation for detailed description of SPM usage. This instruction can address the entire Program memory. The SPM instruction is not available in all devices.",
        "operation": "(RAMPZ:Z) ← R1:R0",
        "type": "DT",
        "incomplete": true,
        "notes": [
            " 1. R1 determines the instruction high byte, and R0 determines the instruction low byte."
        ],
        "opCode": "1001 0101 1110 1000",
        "words": 1,
        "cycles": "Depends on the operation"
    },
    {
        "mnemonic": "spm",
        "name": "Store Program Memory and PostIncrement by 2",
        "description": "SPM can be used to erase a page in the Program memory and to write a page in the Program memory (that is already erased). An entire page can be programmed simultaneously after first filling a temporary page buffer. The Program memory must be erased one page at a time. When erasing the Program memory, the RAMPZ and Z-register are used as page address. When writing the Program memory, the RAMPZ and Z-register are used as page or word address, and the R1:R0 register pair is used as data(1). Refer to the device documentation for detailed description of SPM usage. This instruction can address the entire Program memory.",
        "operation": [
            "(RAMPZ:Z) ← R1:R0",
            "Z ← Z + 2"
        ],
        ,
        "incomplete": true,
        "type": "DT",
        "notes": [
            "1. R1 determines the instruction high byte, and R0 determines the instruction low byte."
        ],
        "opCode": [
            "1001 0101 1110 1000",
            "1001 0101 1111 1000"
        ],
        "words": 1,
        "cycles": "Depends on the operation"
    },
    {
        "mnemonic": "in",
        "name": "In From I/O Location",
        "description": "Loads data from the I/O Space (Ports, Timers, Configuration Registers, etc.) into register Rd in the Register File.",
        "operation": "Rd ← I/O(A)",
        "type": "DT",
        "syntax": "IN Rd,A",
        "operands": {
            "d": "0 ≤ d ≤ 31",
            "A": "0 ≤ A ≤ 63"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1011 0AAd dddd AAAA",
        "examples": [
            "in r25,$16 ; Read Port B",
            "cpi r25,4 ; Compare read value to constant",
            "breq exit ; Branch if r25=4",
            "...",
            "exit: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "out",
        "name": "Out To I/O Location",
        "description": "Stores data from register Rr in the Register File to I/O Space (Ports, Timers, Configuration Registers, etc.).",
        "operation": "I/O(A) ← Rr",
        "type": "DT",
        "syntax": "OUT A,Rr",
        "operands": {
            "r": "0 ≤ r ≤ 31",
            "A": "0 ≤ A ≤ 63"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1011 1AAr rrrr AAAA",
        "examples": [
            "clr r16 ; Clear r16",
            "ser r17 ; Set r17",
            "out $18,r16 ; Write zeros to Port B",
            "nop ; Wait (do nothing)",
            "out $18,r17 ; Write ones to Port B"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "push",
        "name": "Push Register on Stack",
        "description": "This instruction stores the contents of register Rr on the STACK. The Stack Pointer is post-decremented by 1 after the PUSH. This instruction is not available in all devices.",
        "operation": "STACK ← Rr",
        "type": "DT",
        "syntax": "PUSH Rr",
        "operands": {
            "r": "0 ≤ r ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "stack": "SP ← SP - 1",
        "opCode": "1001 001d dddd 1111",
        "examples": [
            "call routine ; Call subroutine",
            "...",
            "routine: push r14 ; Save r14 on the Stack",
            "push r13 ; Save r13 on the Stack",
            "...",
            "pop r13 ; Restore r13",
            "pop r14 ; Restore r14",
            "ret ; Return from subroutine"
        ],
        "words": 1,
        "cycles": {
            "0": 2,
            "x": 1
        }
    },
    {
        "mnemonic": "pop",
        "name": "Pop Register from Stack",
        "description": "This instruction loads register Rd with a byte from the STACK. The Stack Pointer is pre-incremented by 1 before the POP. This instruction is not available in all devices.",
        "operation": "Rd ← STACK",
        "type": "DT",
        "syntax": "POP Rd",
        "operands": {
            "d": "0 ≤ d ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "stack": "SP ← SP + 1",
        "opCode": "1001 000d dddd 1111",
        "examples": [
            "call routine ; Call subroutine",
            "...",
            "routine: push r14 ; Save r14 on the Stack",
            "push r13 ; Save r13 on the Stack",
            "...",
            "pop r13 ; Restore r13",
            "pop r14 ; Restore r14",
            "ret ; Return from subroutine"
        ],
        "words": 1,
        "cycles": 2
    },
    {
        "mnemonic": "xch",
        "name": "Exchange",
        "description": "Exchanges one byte indirect between register and data space. The data location is pointed to by the Z (16 bits) Pointer Register in the Register File. Memory access is limited to the current data segment of 64KB. To access another data segment in devices with more than 64KB data space, the RAMPZ in register in the I/O area has to be changed. The Z-pointer Register is left unchanged by the operation. This instruction is especially suited for writing/ reading status bits stored in SRAM.",
        "operation": [
            "(Z) ← Rd",
            "Rd ← (Z)"
        ],
        "type": "DT",
        "syntax": "XCH Z,Rd",
        "operands": {
            "d": "0 ≤ d ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 001r rrrr 0100",
        "error": true,
        "words": 1,
        "cycles": 2
    },
    {
        "mnemonic": "las",
        "name": "Load and Set",
        "description": "Load one byte indirect from data space to register and set bits in data space specified by the register. The instruction can only be used towards internal SRAM. The data location is pointed to by the Z (16 bits) Pointer Register in the Register File. Memory access is limited to the current data segment of 64KB. To access another data segment in devices with more than 64KB data space, the RAMPZ in register in the I/O area has to be changed. The Z-pointer Register is left unchanged by the operation. This instruction is especially suited for setting status bits stored in SRAM.",
        "operation": [
            "(Z) ← Rd v (Z)",
            "Rd ← (Z)"
        ],
        "type": "DT",
        "syntax": "LAS Z,Rd",
        "operands": {
            "d": "0 ≤ d ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 001r rrrr 0101",
        "words": 1,
        "cycles": 2,
        "error": true
    },
    {
        "mnemonic": "lac",
        "name": "Load and Clear",
        "description": "Load one byte indirect from data space to register and stores and clear the bits in data space specified by the register. The instruction can only be used towards internal SRAM. The data location is pointed to by the Z (16 bits) Pointer Register in the Register File. Memory access is limited to the current data segment of 64KB. To access another data segment in devices with more than 64KB data space, the RAMPZ in register in the I/O area has to be changed. The Z-pointer Register is left unchanged by the operation. This instruction is especially suited for clearing status bits stored in SRAM.",
        "operation": [
            "(Z) ← ($FF – Rd) • (Z)",
            "Rd ← (Z)"
        ],
        "type": "DT",
        "syntax": "LAC Z,Rd",
        "operands": {
            "d": "0 ≤ d ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 001r rrrr 0110",
        "words": 1,
        "cycles": 2,
        "error": true
    },
    {
        "mnemonic": "lat",
        "name": "Load and Toggle",
        "description": "Load one byte indirect from data space to register and toggles bits in the data space specified by the register. The instruction can only be used towards SRAM. The data location is pointed to by the Z (16 bits) Pointer Register in the Register File. Memory access is limited to the current data segment of 64KB. To access another data segment in devices with more than 64KB data space, the RAMPZ in register in the I/O area has to be changed. The Z-pointer Register is left unchanged by the operation. This instruction is especially suited for changing status bits stored in SRAM.",
        "operation": [
            "(Z) ← Rd ⊕ (Z)",
            "Rd ← (Z)"
        ],
        "type": "DT",
        "syntax": "LAT Z,Rd",
        "operands": {
            "d": "0 ≤ d ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 001r rrrr 0111",
        "words": 1,
        "cycles": 2,
        "error": true
    },
    {
        "mnemonic": "lsl",
        "name": "Logical Shift Left",
        "description": "Shifts all bits in Rd one place to the left. Bit 0 is cleared. Bit 7 is loaded into the C Flag of the SREG. This operation effectively multiplies signed and unsigned values by two",
        "operation": [
            "Rd(n+1) ← Rd(n)",
            "Rd(0) ← 0",
            "C ← Rd(7)"
        ],
        "pCounter": "PC ← PC + 1",
        "flags": "Z,C,N,V,H",
        "type": "BT",
        "syntax": "LSL Rd",
        "operands": {
            "d": "0 ≤ d ≤ 31"
        },
        "opCode": "0000 11dd dddd dddd",
        "status": {
            "H": "Rd3",
            "S": "N ⊕ V",
            "V": "N ⊕ C",
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0",
            "C": "Rd7"
        },
        "examples": [
            "add r0,r4 ; Add r4 to r0",
            "lsl r0 ; Multiply r0 by 2"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "lsr",
        "name": "Logical Shift Right",
        "description": "Shifts all bits in Rd one place to the right. Bit 7 is cleared. Bit 0 is loaded into the C Flag of the SREG. This operation effectively divides an unsigned value by two. The C Flag can be used to round the result.",
        "operation": [
            "Rd(n) ← Rd(n+1)",
            "Rd(7) ← 0",
            "C ← Rd(0)"
        ],
        "flags": "Z,C,N,V",
        "type": "BT",
        "syntax": "LSR Rd",
        "operands": {
            "d": "0 ≤ d ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 010d dddd 0110",
        "status": {
            "S": "N ⊕ V",
            "V": "N ⊕ C",
            "N": 0,
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0",
            "C": "Rd0"
        },
        "examples": [
            "add r0,r4 ; Add r4 to r0",
            "lsr r0 ; Divide r0 by 2"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "rol",
        "name": "Rotate Left Through Carry",
        "description": "Shifts all bits in Rd one place to the left. The C Flag is shifted into bit 0 of Rd. Bit 7 is shifted into the C Flag. This operation, combined with LSL, effectively multiplies multi-byte signed and unsigned values by two",
        "operation": [
            "Rd(0) ← C",
            "Rd(n+1) ← Rd(n)",
            "C ← Rd(7)"
        ],
        "flags": "Z,C,N,V,H",
        "type": "BT",
        "syntax": "ROL Rd",
        "operands": {
            "d": "0 ≤ d ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0001 11dd dddd dddd",
        "status": {
            "H": "Rd3",
            "S": "N ⊕ V",
            "V": "N ⊕ C",
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0",
            "C": "Rd7"
        },
        "examples": [
            "lsl r18 ; Multiply r19:r18 by two",
            "rol r19 ; r19:r18 is a signed or unsigned two-byte integer",
            "brcs oneenc ; Branch if carry set",
            "...",
            "oneenc: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "ror",
        "name": "Rotate Right Through Carry",
        "description": "Shifts all bits in Rd one place to the right. The C Flag is shifted into bit 7 of Rd. Bit 0 is shifted into the C Flag. This operation, combined with ASR, effectively divides multi-byte signed values by two. Combined with LSR it effectively divides multi-byte unsigned values by two. The Carry Flag can be used to round the result.",
        "operation": [
            "Rd(7) ← C",
            "Rd(n) ← Rd(n+1)",
            "C ← Rd(0)"
        ],
        "flags": "Z,C,N,V",
        "type": "BT",
        "syntax": "ROR Rd",
        "operands": {
            "d": "0 ≤ d ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 010d dddd 0111",
        "status": {
            "S": "N ⊕ V",
            "V": "N ⊕ C",
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0",
            "C": "Rd0"
        },
        "examples": [
            "lsr r19 ; Divide r19:r18 by two",
            "ror r18 ; r19:r18 is an unsigned two-byte integer",
            "brcc zeroenc1 ; Branch if carry cleared",
            "asr r17 ; Divide r17:r16 by two",
            "ror r16 ; r17:r16 is a signed two-byte integer",
            "brcc zeroenc2 ; Branch if carry cleared",
            "...",
            "zeroenc1: nop ; Branch destination (do nothing)",
            "...",
            "zeroenc1: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "asr",
        "name": "Arithmetic Shift Right",
        "description": "Shifts all bits in Rd one place to the right. Bit 7 is held constant. Bit 0 is loaded into the C Flag of the SREG. This operation effectively divides a signed value by two without changing its sign. The Carry Flag can be used to round the result.",
        "operation": "Rd(n) ← Rd(n+1), n=0..6",
        "flags": "Z,C,N,V",
        "type": "BT",
        "syntax": "ASR Rd",
        "operands": {
            "d": "0 ≤ d ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 010d dddd 0101",
        "status": {
            "S": "N ⊕ V",
            "V": "N ⊕ C",
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0",
            "C": "Rd0"
        },
        "examples": [
            "ldi r16,$10 ; Load decimal 16 into r16",
            "asr r16 ; r16=r16 / 2",
            "ldi r17,$FC ; Load -4 in r17",
            "asr r17 ; r17=r17/2"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "swap",
        "name": "Swap Nibbles",
        "description": "Swaps high and low nibbles in a register.",
        "operation": "Rd(3..0) ↔ Rd(7..4)",
        "type": "BT",
        "syntax": "SWAP Rd",
        "operands": {
            "d": "0 ≤ d ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 010d dddd 0010",
        "examples": [
            "inc r1 ; Increment r1",
            "swap r1 ; Swap high and low nibble of r1",
            "inc r1 ; Increment high nibble of r1",
            "swap r1 ; Swap back"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "sbi",
        "name": "Set Bit in I/O Register",
        "description": "Sets a specified bit in an I/O Register. This instruction operates on the lower 32 I/O Registers – addresses 0-31.",
        "operation": "I/O(A, b) ← 1",
        "type": "BT",
        "syntax": "SBI A,b",
        "operands": {
            "A": "0 ≤ A ≤ 31",
            "b": "0 ≤ b ≤ 7"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 1010 AAAA Abbb",
        "examples": [
            "out $1E,r0 ; Write EEPROM address",
            "sbi $1C,0 ; Set read bit in EECR",
            "in r1,$1D ; Read EEPROM data"
        ],
        "words": 1,
        "cycles": {
            "0": 2,
            "x": 1,
            "tiny": 1
        }
    },
    {
        "mnemonic": "cbi",
        "name": "Clear Bit in I/O Register",
        "description": "Clears a specified bit in an I/O register. This instruction operates on the lower 32 I/O registers – addresses 0-31.",
        "operation": "I/O(A, b) ← 0",
        "type": "BT",
        "syntax": "CBI A,b",
        "operands": {
            "A": "0 ≤ A ≤ 31",
            "b": "0 ≤ b ≤ 7"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 1000 AAAA Abbb",
        "examples": "cbi $12,7 ; Clear bit 7 in Port D",
        "words": 1,
        "cycles": {
            "0": 2,
            "x": 1,
            "tiny": 1
        }
    },
    {
        "mnemonic": "bst",
        "name": "Bit Store from Register to T",
        "description": "Stores bit b from Rd to the T Flag in SREG (Status Register).",
        "operation": "T ← Rr(b)",
        "flags": "T",
        "type": "BT",
        "syntax": "BST Rd,b",
        "operands": {
            "d": "0 ≤ d ≤ 31",
            "b": "0 ≤ b ≤ 7"
        },
        "opCode": "1111 101d dddd 0bbb",
        "status": {
            "T": "0 if bit b in Rd is cleared. Set to 1 otherwise."
        },
        "examples": [
            "bst r1,2 ; Store bit 2 of r1 in T Flag",
            "bld r0,4 ; Load T into bit 4 of r0"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "bld",
        "name": "Bit load from T to Register",
        "description": "Copies the T Flag in the SREG (Status Register) to bit b in register Rd.",
        "operation": "Rd(b) ← T",
        "type": "BT",
        "syntax": "BLD Rd,b",
        "operands": {
            "d": "0 ≤ d ≤ 31",
            "b": "0 ≤ b ≤ 7"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1111 100d dddd 0bbb",
        "examples": [
            "bst r1,2 ; Store bit 2 of r1 in T Flag",
            "bld r0,4 ; Load T Flag into bit 4 of r0"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "bset",
        "name": "Flag Set",
        "description": "Sets a single Flag or bit in SREG.",
        "operation": "SREG(s) ← 1",
        "flags": "SREG(s)",
        "type": "BT",
        "syntax": "BSET s",
        "operands": {
            "s": "0 ≤ s ≤ 7"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 0sss 1000",
        "status": {
            "I": "1 if s = 7; Unchanged otherwise.",
            "T": "1 if s = 6; Unchanged otherwise.",
            "H": "1 if s = 5; Unchanged otherwise.",
            "S": "1 if s = 4; Unchanged otherwise.",
            "V": "1 if s = 3; Unchanged otherwise.",
            "N": "1 if s = 2; Unchanged otherwise.",
            "Z": "1 if s = 1; Unchanged otherwise.",
            "C": "1 if s = 0; Unchanged otherwise."
        },
        "examples": [
            "bset 6 ; Set T Flag",
            "bset 7 ; Enable interrupt"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "bclr",
        "name": "Flag Clear",
        "description": "Clears a single Flag in SREG.",
        "operation": "SREG(s) ← 0",
        "flags": "SREG(s)",
        "type": "BT",
        "syntax": "BCLR s",
        "operands": {
            "s": "0 ≤ s ≤ 7"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 1sss 1000",
        "status": {
            "I": "0 if s = 7; Unchanged otherwise.",
            "T": "0 if s = 6; Unchanged otherwise.",
            "H": "0 if s = 5; Unchanged otherwise.",
            "S": "0 if s = 4; Unchanged otherwise.",
            "V": "0 if s = 3; Unchanged otherwise.",
            "N": "0 if s = 2; Unchanged otherwise.",
            "Z": "0 if s = 1; Unchanged otherwise.",
            "C": "0 if s = 0; Unchanged otherwise."
        },
        "examples": [
            "bclr 0 ; Clear Carry Flag",
            "bclr 7 ; Disable interrupts"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "sec",
        "name": "Set Carry",
        "description": "Sets the Carry Flag (C) in SREG (Status Register).",
        "operation": "C ← 1",
        "flags": "C",
        "type": "BT",
        "syntax": "SEC",
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 0000 1000",
        "status": {
            "C": 1
        },
        "examples": [
            "sec ; Set Carry Flag",
            "adc r0,r1 ; r0=r0+r1+1"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "clc",
        "name": "Clear Carry",
        "description": "Clears the Carry Flag (C) in SREG (Status Register).",
        "operation": "C ← 0",
        "flags": "C",
        "type": "BT",
        "syntax": "CLC",
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 1000 1000",
        "status": {
            "C": "0"
        },
        "examples": [
            "add r0,r0 ; Add r0 to itself",
            "clc ; Clear Carry Flag"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "sen",
        "name": "Set Negative Flag",
        "description": "Sets the Negative Flag (N) in SREG (Status Register)",
        "operation": "N ← 1",
        "flags": "N",
        "type": "BT",
        "syntax": "SEN",
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 0010 1000",
        "status": {
            "N": 1
        },
        "examples": [
            "add r2,r19 ; Add r19 to r2",
            "sen ; Set Negative Flag"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "cln",
        "name": "Clear Negative Flag",
        "description": "Clears the Negative Flag (N) in SREG (Status Register).",
        "operation": "N ← 0",
        "flags": "N",
        "type": "BT",
        "syntax": "CLN",
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 1010 1000",
        "status": {
            "N": "0"
        },
        "examples": [
            "add r2,r3 ; Add r3 to r2",
            "cln ; Clear Negative Flag"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "sez",
        "name": "Set Zero Flag",
        "description": "Sets the Zero Flag (Z) in SREG (Status Register).",
        "operation": "Z ← 1",
        "flags": "Z",
        "type": "BT",
        "syntax": "SEZ",
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 0001 1000",
        "status": {
            "Z": 1
        },
        "examples": [
            "add r2,r19 ; Add r19 to r2",
            "sez ; Set Zero Flag"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "clz",
        "name": "Clear Zero Flag",
        "description": "Clears the Zero Flag (Z) in SREG (Status Register).",
        "operation": "Z ← 0",
        "flags": "Z",
        "type": "BT",
        "syntax": "CLZ",
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 1001 1000",
        "status": {
            "Z": 0
        },
        "examples": [
            "add r2,r3 ; Add r3 to r2",
            "clz ; Clear zero"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "sei",
        "name": "Global Interrupt Enable",
        "description": "Sets the Global Interrupt Flag (I) in SREG (Status Register). The instruction following SEI will be executed before any pending interrupts.",
        "operation": "I ← 1",
        "flags": "I",
        "type": "BT",
        "syntax": "SEI",
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 0111 1000",
        "status": {
            "I": 1
        },
        "examples": [
            "sei ; set global interrupt enable",
            "sleep ; enter sleep, waiting for interrupt",
            "; note: will enter sleep before any pending interrupt(s)"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "cli",
        "name": "Global Interrupt Disable",
        "description": "Clears the Global Interrupt Flag (I) in SREG (Status Register). The interrupts will be immediately disabled. No interrupt will be executed after the CLI instruction, even if it occurs simultaneously with the CLI instruction.",
        "operation": "I ← 0",
        "flags": "I",
        "type": "BT",
        "syntax": "CLI",
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 1111 1000",
        "status": {
            "I": "0"
        },
        "examples": [
            "in temp, SREG ; Store SREG value (temp must be defined by user)",
            "cli ; Disable interrupts during timed sequence",
            "sbi EECR, EEMWE ; Start EEPROM write",
            "sbi EECR, EEWE",
            "out SREG, temp ; Restore SREG value (I-Flag)"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "ses",
        "name": "Set Signed Test Flag",
        "description": "Sets the Signed Flag (S) in SREG (Status Register).",
        "operation": "S ← 1",
        "flags": "S",
        "type": "BT",
        "syntax": "SES",
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 0100 1000",
        "status": {
            "S": 1
        },
        "examples": [
            "add r2,r19 ; Add r19 to r2",
            "ses ; Set Negative Flag"
        ]
    },
    {
        "mnemonic": "cls",
        "name": "Clear Signed Test Flag",
        "description": "Clears the Signed Flag (S) in SREG (Status Register).",
        "operation": "S ← 0",
        "flags": "S",
        "type": "BT",
        "syntax": "CLS",
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 1100 1000",
        "status": {
            "S": 0
        },
        "examples": [
            "add r2,r3 ; Add r3 to r2",
            "cls ; Clear Signed Flag"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "sev",
        "name": "Set Two's Compliment Overflow",
        "description": "Sets the Overflow Flag (V) in SREG (Status Register).",
        "operation": "V ← 1",
        "flags": "V",
        "type": "BT",
        "syntax": "SEV",
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 0011 1000",
        "status": {
            "V": 1
        },
        "examples": [
            "add r2,r19 ; Add r19 to r2",
            "sev ; Set Overflow Flag"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "clv",
        "name": "Clear Two's Compliment Overflow",
        "description": "Clears the Overflow Flag (V) in SREG (Status Register)",
        "operation": "V ← 0",
        "flags": "V",
        "type": "BT",
        "syntax": "CLV",
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 1011 1000",
        "status": {
            "V": 0
        },
        "examples": [
            "add r2,r3 ; Add r3 to r2",
            "clv ; Clear Overflow Flag"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "set",
        "name": "Set T in SREG",
        "description": "Sets the T Flag in SREG (Status Register).",
        "operation": "T ← 1",
        "flags": "T",
        "type": "BT",
        "syntax": "SET",
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 0110 1000",
        "status": {
            "T": 1
        },
        "examples": "set ; Set T Flag",
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "clt",
        "name": "Clear T in SREG",
        "description": "Clears the T Flag in SREG (Status Register).",
        "operation": "T ← 0",
        "flags": "T",
        "type": "BT",
        "syntax": "CTL",
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 1110 1000",
        "status": {
            "T": 0
        },
        "examples": "clt ; Clear T Flag",
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "seh",
        "name": "Set Half Carry Flag in SREG",
        "description": "Sets the Half Carry (H) in SREG (Status Register)",
        "operation": "H ← 1",
        "flags": "H",
        "type": "BT",
        "syntax": "SEH",
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 0101 1000",
        "status": {
            "H": 1
        },
        "examples": "seh ; Set Half Carry Flag",
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "clh",
        "name": "Clear Half Carry Flag in SREG",
        "description": "Clears the Half Carry Flag (H) in SREG (Status Register).",
        "operation": "H ← 0",
        "flags": "H",
        "type": "BT",
        "syntax": "CLH",
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 1101 1000",
        "status": {
            "H": "0"
        },
        "examples": "clh ; Clear the Half Carry Flag",
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "break",
        "name": "Break",
        "description": "The BREAK instruction is used by the On-chip Debug system, and is normally not used in the application software. When the BREAK instruction is executed, the AVR CPU is set in the Stopped Mode. This gives the On-chip Debugger access to internal resources. If any Lock bits are set, or either the JTAGEN or OCDEN Fuses are unprogrammed, the CPU will treat the BREAK instruction as a NOP and will not enter the Stopped mode. This instruction is not available in all devices.",
        "type": "MC",
        "syntax": "BREAK",
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0101 1001 1000",
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "nop",
        "name": "No Operation",
        "description": "This instruction performs a single cycle No Operation.",
        "type": "MC",
        "syntax": "NOP",
        "pCounter": "PC ← PC + 1",
        "opCode": "0000 0000 0000 0000",
        "examples": [
            "clr r16 ; Clear r16",
            "ser r17 ; Set r17",
            "out $18,r16 ; Write zeros to Port B",
            "nop ; Wait (do nothing)",
            "out $18,r17 ; Write ones to Port B"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "sleep",
        "name": "Sleep",
        "description": "This instruction sets the circuit in sleep mode defined by the MCU Control Register",
        "type": "MC",
        "syntax": "SLEEP",
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0101 1000 1000",
        "examples": [
            "mov r0,r11 ; Copy r11 to r0",
            "ldi r16,(1<<SE) ; Enable sleep mode",
            "out MCUCR, r16",
            "sleep ; Put MCU in sleep mode"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "wdr",
        "name": "Watchdog Reset",
        "description": "This instruction resets the Watchdog Timer. This instruction must be executed within a limited time given by the WD prescaler. See the Watchdog Timer hardware specification.",
        "type": "MC",
        "syntax": "WDR",
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0101 1010 1000",
        "examples": "wdr ; Reset watchdog timer",
        "words": 1,
        "cycles": 1
    }
]