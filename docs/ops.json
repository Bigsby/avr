[
    {
        "mnemonic": "adc",
        "name": "Add with Carry",
        "description": "Adds two registers and the contents of the C Flag and places the result in the destination register Rd.",
        "opCode": "0001 11rd dddd rrrr",
        "flags": "Z,C,N,V,S,H",
        "status": {
            "H": "Rd3 • Rr3 + Rr3 • !R3 + !R3 • Rd3",
            "S": "N ⊕ V",
            "V": "Rd7 • Rr7 • !R7 + !Rd7 • !Rr7 • R7",
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0",
            "C": "Rd7 • Rr7 + Rr7 • !R7 + !R7 • Rd7"
        },
        "operation": "Rd ← Rd + Rr + C",
        "operands": {
            "d": "0 ≤ d ≤ 31",
            "r": "0 ≤ r ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "type": "AL",
        "syntax": "ADC Rd,Rr",
        "examples": "adc r3,r1 ; Add with carry high byte"
    },
    {
        "mnemonic": "add",
        "name": "Add without Carry",
        "description": "Adds two registers without the C Flag and places the result in the destination register Rd.",
        "operation": "Rd ← Rd + Rr",
        "flags": "Z,C,N,V,S,H",
        "type": "AL",
        "operands": {
            "d": "0 ≤ d ≤ 31",
            "r": "0 ≤ r ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "syntax": "ADD Rd,Rr",
        "opCode": "0000 11rd dddd rrrr",
        "status": {
            "H": "Rd3 • Rr3 + Rr3 • !R3 + !R3 • Rd3",
            "S": "N ⊕ V",
            "V": "Rd7 • Rr7 • !R7 + !Rd7 • !Rr7 • R7"
        },
        "examples": [
            "add r1,r2 ; Add r2 to r1 (r1=r1+r2)",
            "add r28,r28 ; Add r28 to itself (r28=r28+r28)"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "adiw",
        "name": "Add Immediate to Word",
        "description": "Adds an immediate value (0 - 63) to a register pair and places the result in the register pair. This instruction operates on the upper four register pairs, and is well suited for operations on the pointer registers. This instruction is not available in all devices.",
        "operation": "Rd ← Rd + 1:Rd + K",
        "flags": "Z,C,N,V,S",
        "type": "AL",
        "syntax": "ADIW Rd+1:Rd,K",
        "operands": {
            "d": "d ∈ {24,26,28,30}",
            "K": "0 ≤ K ≤ 63"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0110 KKdd KKKK",
        "status": {
            "S": "N ⊕ V",
            "V": "!Rdh7 • R15",
            "N": "R15",
            "Z": "!R15 • !R14 • !R13 • !R12 • !R11 • !R10 • !R9 • !R8R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0",
            "C": "!R15 • Rdh7"
        },
        "examples": [
            "adiw r25:24,1 ; Add 1 to r25:r24",
            "adiw ZH:ZL,63 ; Add 63 to the Z-pointer(r31:r30)"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "sub",
        "description": "Subtract without Carry",
        "operation": "Rd ← Rd - Rr",
        "flags": "Z,C,N,V,S,H",
        "type": "AL"
    },
    {
        "mnemonic": "subi",
        "description": "Subtract Immediate",
        "operation": "Rd ← Rd - K",
        "flags": "Z,C,N,V,S,H",
        "type": "AL"
    },
    {
        "mnemonic": "sbc",
        "description": "Subtract with Carry",
        "operation": "Rd ← Rd - Rr - C",
        "flags": "Z,C,N,V,S,H",
        "type": "AL"
    },
    {
        "mnemonic": "sbci",
        "description": "Subtract Immediate with Carry",
        "operation": "Rd ← Rd - K - C",
        "flags": "Z,C,N,V,S,H",
        "type": "AL"
    },
    {
        "mnemonic": "sbiw",
        "description": "Subtract Immediate from Word",
        "operation": "Rd + 1:Rd ← Rd + 1:Rd - K",
        "flags": "Z,C,N,V,S",
        "type": "AL"
    },
    {
        "mnemonic": "and",
        "name": "Logical AND",
        "description": "Performs the logical AND between the contents of register Rd and register Rr, and places the result in the destination register Rd.",
        "operation": "Rd ← Rd • Rr",
        "flags": "Z,N,V,S",
        "type": "AL",
        "syntax": "AND Rd,Rr",
        "operands": {
            "d": "0 ≤ d ≤ 31",
            "r": "0 ≤ r ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0010 00rd dddd rrrr",
        "status": {
            "S": "N ⊕ V",
            "V": "0",
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0"
        },
        "examples": [
            "and r2,r3 ; Bitwise and r2 and r3, result in r2",
            "and r2,r16 ; Isolate bit 0 in r2"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "andi",
        "name": "Logical AND with Immediate",
        "description": "Performs the logical AND between the contents of register Rd and a constant, and places the result in the destination register Rd.",
        "operation": "Rd ← Rd • K",
        "flags": "Z,N,V,S",
        "type": "AL",
        "syntax": "ANDI Rd,K",
        "operands": {
            "d": "16 ≤ d ≤ 31",
            "K": "0 ≤ K ≤ 255"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0111 KKKK dddd KKKK",
        "status": {
            "S": "N ⊕ V",
            "V": "0",
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0"
        },
        "examples": [
            "andi r17,$0F ; Clear upper nibble of r17",
            "andi r18,$10 ; Isolate bit 4 in r18",
            "andi r19,$AA ; Clear odd bits of r19"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "or",
        "description": "Logical OR",
        "operation": "Rd ← Rd v Rr",
        "flags": "Z,N,V,S",
        "type": "AL"
    },
    {
        "mnemonic": "ori",
        "description": "Logical OR with Immediate",
        "operation": "Rd v K",
        "flags": "Z,N,V,S",
        "type": "AL"
    },
    {
        "mnemonic": "eor",
        "name": "Exclusive OR",
        "description": "Performs the logical EOR between the contents of register Rd and register Rr and places the result in the destination register Rd.",
        "operation": "Rd ← Rd ⊕ Rr",
        "flags": "Z,N,V,S",
        "type": "AL",
        "syntax": "EOR Rd,Rr",
        "operands": {
            "d": "0 ≤ d ≤ 31",
            "r": "0 ≤ r ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0010 01rd dddd rrrr",
        "status": {
            "S": "N ⊕ V",
            "V": 0,
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0"
        },
        "examples": [
            "eor r4,r4 ; Clear r4",
            "eor r0,r22 ; Bitwise exclusive or between r0 and r22"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "com",
        "name": "One's Complement",
        "description": "This instruction performs a One’s Complement of register Rd.",
        "operation": "Rd ← $FF - Rd",
        "flags": "Z,C,N,V,S",
        "type": "AL",
        "syntax": "COM Rd",
        "operands": {
            "d": "0 ≤ d ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "status": {
            "S": "N ⊕ V",
            "V": 0,
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0",
            "C": 1
        },
        "examples": [
            "com r4 ; Take one’s complement of r4",
            "breq zero ; Branch if zero",
            "...",
            "zero: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "neg",
        "description": "Two’s Complement",
        "operation": "Rd ← $00 - Rd",
        "flags": "Z,C,N,V,S,H",
        "type": "AL"
    },
    {
        "mnemonic": "sbr",
        "description": "Set Bit(s) in Register",
        "operation": "Rd ← Rd v K",
        "flags": "Z,N,V,S",
        "type": "AL"
    },
    {
        "mnemonic": "cbr",
        "name": "Clear Bit(s) in Register",
        "description": "Clears the specified bits in register Rd. Performs the logical AND between the contents of register Rd and the complement of the constant mask K. The result will be placed in register Rd.",
        "operation": "Rd ← Rd • ($FFh -K)",
        "flags": "Z,N,V,S",
        "type": "AL",
        "syntax": "CBR Rd,K",
        "operands": {
            "d": "16 ≤ d ≤ 31",
            "K": "0 ≤ K ≤ 255"
        },
        "pCounter": "PC ← PC + 1",
        "status": {
            "S": "N ⊕ V",
            "V": "0",
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0"
        },
        "examples": [
            "cbr r16,$F0 ; Clear upper nibble of r16",
            "cbr r18,1 ; Clear bit 0 in r18"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "inc",
        "name": "Increment",
        "description": "Adds one -1- to the contents of register Rd and places the result in the destination register Rd. The C Flag in SREG is not affected by the operation, thus allowing the INC instruction to be used on a loop counter in multiple-precision computations. When operating on unsigned numbers, only BREQ and BRNE branches can be expected to perform consistently. When operating on two’s complement values, all signed branches are available.",
        "operation": "Rd ← Rd + 1 ",
        "flags": "Z,N,V,S",
        "type": "AL",
        "syntax": "INC Rd",
        "operands": {
            "d": "0 ≤ d ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 010d dddd 0011",
        "status": {
            "S": "N ⊕ V",
            "V": "R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0",
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0"
        },
        "examples": [
            "clr r22 ; clear r22",
            "loop: inc r22 ; increment r22",
            "...",
            "cpi r22,$4F ; Compare r22 to $4f",
            "brne loop ; Branch if not equal",
            "nop ; Continue (do nothing)"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "dec",
        "name": "Decrement",
        "description": "Subtracts one -1- from the contents of register Rd and places the result in the destination register Rd. The C Flag in SREG is not affected by the operation, thus allowing the DEC instruction to be used on a loop counter in multiple-precision computations. When operating on unsigned values, only BREQ and BRNE branches can be expected to perform consistently. When operating on two’s complement values, all signed branches are available.",
        "operation": "Rd ← Rd - 1",
        "flags": "Z,N,V,S",
        "type": "AL",
        "syntax": "DEC Rd",
        "pCounter": "PC ← PC + 1",
        "operands": {
            "d": "0 ≤ d ≤ 31"
        },
        "opCode": "1001 010d dddd 1010",
        "status": {
            "S": "N ⊕ V",
            "V": "!R7 • R6 • R5 • R4 • R3 • R2 • R1 • R0",
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0"
        },
        "examples": [
            "ldi r17,$10 ; Load constant in r17",
            "loop: add r1,r2 ; Add r2 to r1",
            "dec r17 ; Decrement r17",
            "brne loop ; Branch if r17<>0",
            "nop ; Continue (do nothing)"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "tst",
        "description": "Test for Zero or Minus",
        "operation": "Rd ← Rd • Rd",
        "flags": "Z,N,V,S",
        "type": "AL"
    },
    {
        "mnemonic": "clr",
        "name": "Clear Register",
        "description": "Clears a register. This instruction performs an Exclusive OR between a register and itself. This will clear all bits in the register.",
        "operation": "Rd ← Rd ⊕ Rd",
        "flags": "Z,N,V,S",
        "type": "AL",
        "syntax": "CLR Rd",
        "operands": {
            "d": "0 ≤ d ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0010 01dd dddd dddd",
        "status": {
            "S": 0,
            "V": 0,
            "N": 0,
            "Z": 1
        },
        "examples": [
            " clr r18 ; clear r18",
            "loop: inc r18 ; increase r18",
            "...",
            "cpi r18,$50 ; Compare r18 to $50",
            "brne loop"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "ser",
        "description": "Set Register",
        "operation": "Rd ← $FF",
        "flags": "",
        "type": "AL"
    },
    {
        "mnemonic": "mul",
        "description": "Multiply Unsigned",
        "operation": "R1:R0 ← Rd x Rr (UU)",
        "flags": "Z,C",
        "type": "AL"
    },
    {
        "mnemonic": "muls",
        "description": "Multiply Signed",
        "operation": "R1:R0 ← Rd x Rr (SS)",
        "flags": "Z,C",
        "type": "AL"
    },
    {
        "mnemonic": "mulsu",
        "description": "Multiply Signed with Unsigned",
        "operation": "R1:R0 ← Rd x Rr (SU)",
        "flags": "Z,C",
        "type": "AL"
    },
    {
        "mnemonic": "fmul",
        "name": "Fractional Multiply Unsigned",
        "description": "This instruction performs 8-bit × 8-bit → 16-bit unsigned multiplication and shifts the result one bit left",
        "operation": "R1:R0 ← Rd x Rr<<1 (UU)",
        "flags": "Z,C",
        "type": "AL",
        "syntax": "FMUL Rd,Rr",
        "opCode": "0000 0011 0ddd 1rrr",
        "status": {
            "C": "R16",
            "Z": "!R15 • !R14 • !R13 • !R12 • !R11 • !R10 • !R9 • !R8R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0"
        },
        "incomplete": true,
        "operands": {
            "d": "16 ≤ d ≤ 23",
            "r": "16 ≤ d ≤ 23"
        },
        "pCounter": "PC ← PC + 1",
        "words": 1,
        "cycles": 2
    },
    {
        "mnemonic": "fmuls",
        "name": "Fractional Multiply Signed",
        "description": "This instruction performs 8-bit × 8-bit → 16-bit signed multiplication and shifts the result one bit left.",
        "operation": "R1:R0 ← Rd x Rr<<1 (SS)",
        "flags": "Z,C",
        "type": "AL",
        "syntax": "FMULS Rd,Rr",
        "incomplete": true,
        "operands": {
            "d": "16 ≤ d ≤ 23",
            "r": "16 ≤ d ≤ 23"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0000 0011 1ddd 0rrr",
        "status": {
            "C": "R16",
            "Z": "!R15 • !R14 • !R13 • !R12 • !R11 • !R10 • !R9 • !R8R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0"
        },
        "examples": [
            "fmuls r23,r22 ; Multiply signed r23 and r22 in (1.7) format, result in (1.15) format",
            "mov w r23:r22,r1:r0 ; Copy result back in r23:r22"
        ],
        "words": 1,
        "cycles": 2
    },
    {
        "mnemonic": "fmulsu",
        "name": "Fractional Multiply Signed with Unsigned",
        "description": "This instruction performs 8-bit × 8-bit → 16-bit signed multiplication and shifts the result one bit left.",
        "operation": "R1:R0 ← Rd x Rr<<1 (SU)",
        "incomplete": true,
        "flags": "Z,C",
        "type": "AL",
        "syntax": "FMULSU Rd,Rr",
        "operands": {
            "d": "16 ≤ d ≤ 23",
            "r": "16 ≤ d ≤ 23"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0000 0011 1ddd 1rrr",
        "status": {
            "C": "R16",
            "Z": "!R15 • !R14 • !R13 • !R12 • !R11 • !R10 • !R9 • !R8R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0"
        },
        "words": 1,
        "cycles": 2
    },
    {
        "mnemonic": "des",
        "name": "Data Encryption",
        "description": "The module is an instruction set extension to the AVR CPU, performing DES iterations. The 64-bit data block (plaintext or ciphertext) is placed in the CPU register file, registers R0-R7, where LSB of data is placed in LSB of R0 and MSB of data is placed in MSB of R7. The full 64-bit key (including parity bits) is placed in registers R8-R15, organized in the register file with LSB of key in LSB of R8 and MSB of key in MSB of R15. Executing one DES instruction performs one round in the DES algorithm. Sixteen rounds must be executed in increasing order to form the correct DES ciphertext or plaintext. Intermediate results are stored in the register file (R0-R15) after each DES instruction. The instruction's operand (K) determines which round is executed, and the half carry flag (H) determines whether encryption or decryption is performed. The DES algorithm is described in “Specifications for the Data Encryption Standard” (Federal Information Processing Standards Publication 46). Intermediate results in this implementation differ from the standard because the initial permutation and the inverse initial permutation are performed in each iteration. This does not affect the result in the final ciphertext or plaintext, but reduces the execution time.",
        "operation": [
            "if (H = 0) then R15:R0 ← Encrypt(R15:R0, K)",
            "else if (H = 1) then R15:R0 ← Decrypt(R15:R0, K)"
        ],
        "flags": "",
        "type": "AL",
        "syntax": "DES K",
        "operands": {
            "K": "0x00 ≤ K ≤ 0x0F"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 KKKK 1011",
        "examples": [
            "DES 0x00",
            "DES 0x01",
            "...",
            "DES 0x0E",
            "DES 0x0F"
        ],
        "words": 1,
        "cycles": 1,
        "notes": "If the DES instruction is succeeding a non-DES instruction, an extra cycle is inserted."
    },
    {
        "mnemonic": "rjmp",
        "description": "Relative Jump",
        "operation": "PC ← PC + k + 1",
        "type": "BR"
    },
    {
        "mnemonic": "ijmp",
        "name": "Indirect Jump to (Z)",
        "description": "Indirect jump to the address pointed to by the Z (16 bits) Pointer Register in the Register File. The Zpointer Register is 16 bits wide and allows jump within the lowest 64K words (128KB) section of Program memory. This instruction is not available in all devices.",
        "operation": [
            "PC(15:0) ← Z",
            "PC(21:16) ← 0"
        ],
        "incomplete": true,
        "type": "BR",
        "syntax": "IJMP",
        "opCode": "1001 0100 0000 1001",
        "examples": [
            "mov r30,r0 ; Set offset to jump table",
            "ijmp ; Jump to routine pointed to by r31:r30"
        ],
        "words": 1,
        "cycles": 2
    },
    {
        "mnemonic": "eijmp",
        "name": "Extended Indirect Jump to (Z)",
        "description": "ndirect jump to the address pointed to by the Z (16 bits) Pointer Register in the Register File and the EIND Register in the I/O space. This instruction allows for indirect jumps to the entire 4M (words) Program memory space. See also IJMP. This instruction is not available in all devices.",
        "operation": [
            "PC(15:0) ← Z",
            "PC(21:16) ← EIND"
        ],
        "type": "BR",
        "syntax": "EIJMP",
        "examples": [
            "ldi r16,$05 ; Set up EIND and Z-pointer",
            "out EIND,r16",
            "ldi r30,$00",
            "ldi r31,$10",
            "eijmp ; Jump to $051000"
        ],
        "words": 1,
        "cycles": 2
    },
    {
        "mnemonic": "jmp",
        "name": "Jump",
        "description": "Jump to an address within the entire 4M (words) Program memory. See also RJMP. This instruction is not available in all devices.",
        "operation": "PC ← k",
        "type": "BR",
        "syntax": "JMP k",
        "operands": {
            "k": "0 ≤ k ≤ 4M"
        },
        "opCode": [
            "1001 010k kkkk 110k",
            "kkkk kkkk kkkk kkkk"
        ],
        "examples": [
            "mov r1,r0 ; Copy r0 to r1",
            "jmp farplc ; Unconditional jump",
            "...",
            "farplc: nop ; Jump destination (do nothing)"
        ],
        "words": 2,
        "cycles": 3
    },
    {
        "mnemonic": "rcall",
        "description": "Relative Call Subroutine",
        "operation": "PC ← PC + k + 1",
        "type": "BR"
    },
    {
        "mnemonic": "icall",
        "name": "Indirect Call to (Z)",
        "description": "Calls to a subroutine within the entire 4M (words) Program memory. The return address (to the instruction after the CALL) will be stored onto the Stack. See also RCALL. The Stack Pointer uses a post-decrement scheme during CALL. This instruction is not available in all devices.",
        "operation": [
            "PC(15:0) ← Z",
            "PC(21:16) ← 0"
        ],
        "incomplete": true,
        "type": "BR",
        "syntax": "ICALL",
        "opCode": "1001 0101 0000 1001",
        "examples": [
            "mov r30,r0 ; Set offset to call table",
            "icall ; Call routine pointed to by r31:r30"
        ],
        "words": 1,
        "cycles": {
            "0": {
                "16bit": 3,
                "22bit": 4
            },
            "x": {
                "16Bit": 2,
                "22bit": 3
            }
        }
    },
    {
        "mnemonic": "eicall",
        "name": "Extended Indirect Call to (Z)",
        "description": "Indirect call of a subroutine pointed to by the Z (16 bits) Pointer Register in the Register File and the EIND Register in the I/O space. This instruction allows for indirect calls to the entire 4M (words) Program memory space. See also ICALL. The Stack Pointer uses a post-decrement scheme during EICALL. This instruction is not available in all devices.",
        "operation": [
            "PC(15:0) ← Z",
            "PC(21:16) ← EIND"
        ],
        "type": "BR",
        "syntax": "EICALL",
        "stack": [
            "STACK ← PC + 1",
            "SP ← SP - 3 (3 bytes, 22 bits)"
        ],
        "opCode": "1001 0101 0001 1001",
        "examples": [
            "ldi r16,$05 ; Set up EIND and Z-pointer",
            "out EIND,r16",
            "ldi r30,$00",
            "ldi r31,$10",
            "eicall ; Call to $051000"
        ],
        "words": 1,
        "cycles": {
            "0": 4,
            "x": 3
        },
        "notes": "only implemented in devices with 22-bit PC"
    },
    {
        "mnemonic": "call",
        "name": "Call Subroutine",
        "description": "Calls to a subroutine within the entire Program memory. The return address (to the instruction after the CALL) will be stored onto the Stack. (See also RCALL). The Stack Pointer uses a post-decrement scheme during CALL. This instruction is not available in all devices.",
        "operation": "PC ← k",
        "operations": {
            "16bitPC": {
                "operands": {
                    "k": "0 ≤ k ≤ 64K"
                },
                "stack": [
                    "STACK ← PC+2",
                    "SP ← SP-2, (2 bytes, 16 bits)"
                ]
            },
            "22bitPC": {
                "operands": {
                    "k": "0 ≤ k ≤ 4M"
                },
                "stack": [
                    "STACK ← PC+2",
                    "SP ← SP-3, (3 bytes, 22 bits)"
                ]
            }
        },
        "type": "BR",
        "syntax": "CALL k",
        "opCode": [
            "1001 010k kkkk 111k",
            "kkkk kkkk kkkk kkkk"
        ],
        "examples": [
            "mov r16,r0 ; Copy r0 to r16",
            "call check ; Call subroutine",
            "nop ; Continue (do nothing)",
            "...",
            "check: cpi r16,$42 ; Check if r16 has a special value",
            "breq error ; Branch if equal",
            "ret ; Return from subroutine",
            "...",
            "error: rjmp error ; Infinite loop"
        ],
        "words": 2,
        "cycles": {
            "0": {
                "16bit": 4,
                "22bit": 5
            },
            "x": {
                "16Bit": 3,
                "22bit": 4
            }
        }
    },
    {
        "mnemonic": "ret",
        "description": "Subroutine Return",
        "operation": "PC ← STACK",
        "type": "BR"
    },
    {
        "mnemonic": "reti",
        "description": "Interrupt Return",
        "operation": "PC ← STACK",
        "flags": "I",
        "type": "BR"
    },
    {
        "mnemonic": "cpse",
        "name": "Compare, skip if Equal",
        "description": "This instruction performs a compare between two registers Rd and Rr, and skips the next instruction if Rd = Rr.",
        "operation": "if (Rd = Rr) PC ← PC + 2 or 3 else PC ← PC + 1",
        "type": "BR",
        "syntax": "CPSE Rd,Rr",
        "operands": {
            "d": "0 ≤ d ≤ 31",
            "r": "0 ≤ r ≤ 31"
        },
        "pCounter": [
            "PC ← PC + 1, Condition false - no skip",
            "PC ← PC + 2, Skip a one word instruction",
            "PC ← PC + 3, Skip a two word instruction"
        ],
        "opCode": "0001 00rd dddd rrrr",
        "examples": [
            "inc r4 ; Increase r4",
            "cpse r4,r0 ; Compare r4 to r0",
            "neg r4 ; Only executed if r4<>r0",
            "nop ; Continue (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false (no skip)",
            "2 if condition is true (skip is executed) and the instruction skipped is 1 word",
            "3 if condition is true (skip is executed) and the instruction skipped is 2 words"
        ]
    },
    {
        "mnemonic": "cp",
        "name": "Compare",
        "description": "This instruction performs a compare between two registers Rd and Rr. None of the registers are changed. All conditional branches can be used after this instruction.",
        "operation": "Rd - Rr",
        "flags": "Z,C,N,V,S,H",
        "type": "BR",
        "syntax": "CP Rd,Rr",
        "operands": {
            "d": "0 ≤ d ≤ 31",
            "r": "0 ≤ r ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0001 01rd dddd rrrr",
        "status": {
            "H": "!Rd3 • Rr3 + Rr3 • R3 + R3 • !Rd3",
            "S": "N ⊕ V",
            "V": "Rd7 • Rr7 • !R7 + !Rd7 • !Rr7 • R7",
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0",
            "C": "!Rd7 • Rr7 + Rr7 • R7 + R7 • !Rd7"
        },
        "examples": [
            "cp r4,r19 ; Compare r4 with r19",
            "brne noteq ; Branch if r4 <> r19",
            "...",
            "noteq: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "cpc",
        "name": "Compare with Carry",
        "description": "This instruction performs a compare between two registers Rd and Rr and also takes into account the previous carry. None of the registers are changed. All conditional branches can be used after this instruction.",
        "operation": "Rd - Rr - C",
        "flags": "Z,C,N,V,S,H",
        "type": "BR",
        "syntax": "CPC Rd,Rr",
        "operands": {
            "d": "0 ≤ d ≤ 31",
            "r": "0 ≤ r ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0000 01rd dddd rrrr",
        "status": {
            "H": "!Rd3 • Rr3 + Rr3 • R3 + R3 • !Rd3",
            "S": "N ⊕ V",
            "V": "Rd7 • !Rr7 • !R7 + !Rd7 • Rr7 • R7",
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0",
            "C": "!Rd7 • Rr7 + Rr7 • R7 + R7 • !Rd7"
        },
        "examples": [
            "; Compare r3:r2 with r1:r0",
            "cp r2,r0 ; Compare low byte",
            "cpc r3,r1 ; Compare high byte",
            "brne noteq ; Branch if not equal",
            "...",
            "noteq: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "cpi",
        "name": "Compare with Immediate",
        "description": "This instruction performs a compare between register Rd and a constant. The register is not changed. All conditional branches can be used after this instruction.",
        "operation": "Rd - K",
        "flags": "Z,C,N,V,S,H",
        "type": "BR",
        "syntax": "CPI Rd,K",
        "operands": {
            "d": "16 ≤ d ≤ 31",
            "K": "0 ≤ K ≤ 255"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0011 KKKK dddd KKKK",
        "status": {
            "H": "!Rd3 • K3 + K3 • R3 + R3 • !Rd3",
            "S": "N ⊕ V",
            "V": "Rd7 • !K7 • !R7 + !Rd7 • K7 • R7",
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0",
            "C": "!Rd7 • K7 + K7 • R7 + R7 • !Rd7"
        },
        "examples": [
            "cpi r19,3 ; Compare r19 with 3",
            "brne error ; Branch if r19<>3",
            "...",
            "error: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "sbrc",
        "description": "Skip if Bit in Register Cleared",
        "operation": "if (Rr(b) = 0) PC ← PC + 2 or 3",
        "type": "BR"
    },
    {
        "mnemonic": "sbrs",
        "description": "Skip if Bit in Register Set",
        "operation": "if (Rr(b) = 1) PC ← PC + 2 or 3",
        "type": "BR"
    },
    {
        "mnemonic": "sbic",
        "description": "Skip if Bit in I/O Register Cleared",
        "operation": "if (I/O(A,b) = 0) PC ← PC + 2 or 3",
        "type": "BR"
    },
    {
        "mnemonic": "sbis",
        "description": "Skip if Bit in I/O Register Set",
        "operation": "If (I/O(A,b) =1) PC ← PC + 2 or 3 ",
        "type": "BR"
    },
    {
        "mnemonic": "brbs",
        "name": "Branch if Status Flag Set",
        "description": "Conditional relative branch. Tests a single bit in SREG and branches relatively to PC if the bit is set. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form.",
        "operation": "if (SREG(s) = 1) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRBS s,k",
        "operands": {
            "s": "0 ≤ s ≤ 7",
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 00kk kkkk ksss",
        "examples": [
            "bst r0,3 ; Load T bit with bit 3 of r0",
            "brbs 6,bitset ; Branch T bit was set",
            "...",
            "bitset: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brbc",
        "name": "Branch if Status Flag Cleared",
        "description": "Conditional relative branch. Tests a single bit in SREG and branches relatively to PC if the bit is cleared. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form.",
        "operation": "if (SREG(s) = 0) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRBC s,k",
        "operands": {
            "s": "0 ≤ s ≤ 7",
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 01kk kkkk ksss",
        "examples": [
            "cpi r20,5 ; Compare r20 to the value 5",
            "brbc 1,noteq ; Branch if Zero Flag cleared",
            "...",
            "noteq: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "breq",
        "name": "Branch if Equal",
        "description": "Conditional relative branch. Tests the Zero Flag (Z) and branches relatively to PC if Z is set. If the instruction is executed immediately after any of the instructions CP, CPI, SUB, or SUBI, the branch will occur if and only if the unsigned or signed binary number represented in Rd was equal to the unsigned or signed binary number represented in Rr. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBS 1,k.)",
        "operation": "if (Z = 1) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BREQ k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 00kk kkkk k001",
        "examples": [
            "cp r1,r0 ; Compare registers r1 and r0",
            "breq equal ; Branch if registers equal",
            "...",
            "equal: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brne",
        "name": "Branch if Not Equal",
        "description": "Conditional relative branch. Tests the Zero Flag (Z) and branches relatively to PC if Z is cleared. If the instruction is executed immediately after any of the instructions CP, CPI, SUB, or SUBI, the branch will occur if and only if, the unsigned or signed binary number represented in Rd was not equal to the unsigned or signed binary number represented in Rr. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBC 1,k.)",
        "operation": "if (Z = 0) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRNE k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 01kk kkkk k001",
        "examples": [
            "eor r27,r27 ; Clear r27",
            "loop: inc r27 ; Increase r27",
            "...",
            "cpi r27,5 ; Compare r27 to 5",
            "brne loop ; Branch if r27<>5",
            "nop ; Loop exit (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brcs",
        "name": "Branch if Carry Set",
        "description": "Conditional relative branch. Tests the Carry Flag (C) and branches relatively to PC if C is set. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBS 0,k.)",
        "operation": "if (C = 1) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRCS k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 00kk kkkk k000",
        "examples": [
            "cpi r26,$56 ; Compare r26 with $56",
            "brcs carry ; Branch if carry set",
            "...",
            "carry: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brcc",
        "name": "Branch if Carry Cleared",
        "description": "Conditional relative branch. Tests the Carry Flag (C) and branches relatively to PC if C is cleared. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBC 0,k.)",
        "operation": "if (C = 0) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRCC k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 01kk kkkk k000",
        "examples": [
            "add r22,r23 ; Add r23 to r22",
            "brcc nocarry ; Branch if carry cleared",
            "...",
            "nocarry: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brsh",
        "name": "Branch if Same or Higher",
        "description": "Conditional relative branch. Tests the Carry Flag (C) and branches relatively to PC if C is cleared. If the instruction is executed immediately after execution of any of the instructions CP, CPI, SUB, or SUBI, the branch will occur if and only if, the unsigned binary number represented in Rd was greater than or equal to the unsigned binary number represented in Rr. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBC 0,k.)",
        "operation": "if (C = 0) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRSH k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 01kk kkkk k000",
        "examples": [
            "subi r19,4 ; Subtract 4 from r19",
            "brsh highsm ; Branch if r19 >= 4 (unsigned)",
            "...",
            "highsm: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brlo",
        "name": "Branch if Lower",
        "description": "Conditional relative branch. Tests the Carry Flag (C) and branches relatively to PC if C is set. If the instruction is executed immediately after any of the instructions CP, CPI, SUB, or SUBI, the branch will occur if and only if, the unsigned binary number represented in Rd was smaller than the unsigned binary number represented in Rr. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBS 0,k.)",
        "operation": "if (C = 1) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRLO k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 00kk kkkk k000",
        "examples": [
            "eor r19,r19 ; Clear r19",
            "loop: inc r19 ; Increase r19",
            "...",
            "cpi r19,$10 ; Compare r19 with $10",
            "brlo loop ; Branch if r19 < $10 (unsigned)",
            "nop ; Exit from loop (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brmi",
        "name": "Branch if Minus",
        "description": "Conditional relative branch. Tests the Negative Flag (N) and branches relatively to PC if N is set. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBS 2,k.)",
        "operation": "if (N = 1) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRMI k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 00kk kkkk k010",
        "examples": [
            "subi r18,4 ; Subtract 4 from r18",
            "brmi negative ; Branch if result negative",
            "...",
            "negative: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brpl",
        "name": "Branch if Plus",
        "description": "Conditional relative branch. Tests the Negative Flag (N) and branches relatively to PC if N is cleared. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBC 2,k.)",
        "operation": "if (N = 0) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRPL k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 01kk kkkk k010",
        "examples": [
            "subi r26,$50 ; Subtract $50 from r26",
            "brpl positive ; Branch if r26 positive",
            "...",
            "positive: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brge",
        "name": "Branch if Greater or Equal, Signed",
        "description": "Conditional relative branch. Tests the Signed Flag (S) and branches relatively to PC if S is cleared. If the instruction is executed immediately after any of the instructions CP, CPI, SUB, or SUBI, the branch will occur if and only if the signed binary number represented in Rd was greater than or equal to the signed binary number represented in Rr. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBC 4,k.)",
        "operation": "if (N ⊕ V= 0) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRGE k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 01kk kkkk k100",
        "examples": [
            "cp r11,r12 ; Compare registers r11 and r12",
            "brge greateq ; Branch if r11 ≥ r12 (signed)",
            "...",
            "greateq: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brlt",
        "name": "Branch if Less Than, Signed",
        "description": "Conditional relative branch. Tests the Signed Flag (S) and branches relatively to PC if S is set. If the instruction is executed immediately after any of the instructions CP, CPI, SUB, or SUBI, the branch will occur if and only if, the signed binary number represented in Rd was less than the signed binary number represented in Rr. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBS 4,k.)",
        "operation": "if (N ⊕ V= 1) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRLT k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 00kk kkkk k100",
        "examples": [
            "cp r16,r1 ; Compare r16 to r1",
            "brlt less ; Branch if r16 < r1 (signed)",
            "...",
            "less: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brhs",
        "name": "Branch if Half Carry Flag Set",
        "description": "Conditional relative branch. Tests the Half Carry Flag (H) and branches relatively to PC if H is set. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBS 5,k.)",
        "operation": "if (H = 1) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRHS k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 00kk kkkk k101",
        "examples": [
            "brhs hset ; Branch if Half Carry Flag set",
            "...",
            "hset: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brhc",
        "name": "Branch if Half Carry Flag Cleared",
        "description": "Conditional relative branch. Tests the Half Carry Flag (H) and branches relatively to PC if H is cleared. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBC 5,k.)",
        "operation": "if (H = 0) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRHC k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 01kk kkkk k101",
        "examples": [
            "brhc hclear ; Branch if Half Carry Flag cleared",
            "...",
            "hclear: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brts",
        "name": "Branch if T Flag Set",
        "description": "Conditional relative branch. Tests the T Flag and branches relatively to PC if T is set. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBS 6,k.)",
        "operation": "if (T = 1) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRTS k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 00kk kkkk k110",
        "examples": [
            "bst r3,5 ; Store bit 5 of r3 in T Flag",
            "brts tset ; Branch if this bit was set",
            "...",
            "tset: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brtc",
        "name": "Branch if T Flag Cleared",
        "description": "Conditional relative branch. Tests the T Flag and branches relatively to PC if T is cleared. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBC 6,k.)",
        "operation": "if (T = 0) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRTC k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 01kk kkkk k110",
        "examples": [
            "bst r3,5 ; Store bit 5 of r3 in T Flag",
            "brtc tclear ; Branch if this bit was cleared",
            "...",
            "tclear: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brvs",
        "name": "Branch if Overflow Flag is Set",
        "description": "Conditional relative branch. Tests the Overflow Flag (V) and branches relatively to PC if V is set. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBS 3,k.)",
        "operation": "if (V = 1) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRVS k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 00kk kkkk k011",
        "examples": [
            "add r3,r4 ; Add r4 to r3",
            "brvs overfl ; Branch if overflow",
            "...",
            "overfl: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brvc",
        "name": "Branch if Overflow Flag is Cleared",
        "description": "Conditional relative branch. Tests the Overflow Flag (V) and branches relatively to PC if V is cleared. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBC 3,k.)",
        "operation": "if (V = 0) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRVC k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 01kk kkkk k011",
        "examples": [
            "add r3,r4 ; Add r4 to r3",
            "brvc noover ; Branch if no overflow",
            "...",
            "noover: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brie",
        "name": "Branch if Interrupt Enabled",
        "description": "Conditional relative branch. Tests the Global Interrupt Flag (I) and branches relatively to PC if I is set. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBS 7,k.)",
        "operation": "if (I = 1) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRIE k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 00kk kkkk k111",
        "examples": [
            "brie inten ; Branch if interrupt enabled",
            "...",
            "inten: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "brid",
        "name": "Branch if Interrupt Disabled",
        "description": "Conditional relative branch. Tests the Global Interrupt Flag (I) and branches relatively to PC if I is cleared. This instruction branches relatively to PC in either direction (PC - 63 ≤ destination ≤ PC + 64). Parameter k is the offset from PC and is represented in two’s complement form. (Equivalent to instruction BRBC 7,k.)",
        "operation": "if (I = 0) then PC ← PC + k + 1, else PC ← PC + 1",
        "type": "BR",
        "syntax": "BRID k",
        "operands": {
            "k": "-64 ≤ k ≤ +63"
        },
        "opCode": "1111 01kk kkkk k111",
        "examples": [
            "brid intdis ; Branch if interrupt disabled",
            "...",
            "intdis: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": [
            "1 if condition is false",
            "2 if condition is true"
        ]
    },
    {
        "mnemonic": "mov",
        "name": "Copy Register",
        "description": "This instruction makes a copy of one register into another. The source register Rr is left unchanged, while the destination register Rd is loaded with a copy of Rr.",
        "operation": "Rd ← Rr",
        "type": "DT",
        "syntax": "MOV Rd,Rr",
        "operands": {
            "d": "0 ≤ d ≤ 31",
            "r": "0 ≤ r ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0010 11rd dddd rrrr",
        "examples": [
            "mov r16,r0 ; Copy r0 to r16",
            "call check ; Call subroutine",
            "...",
            "check: cpi r16,$11 ; Compare r16 to $11",
            "...",
            "ret ; Return from subroutine"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "movw",
        "name": "Copy Register Pair",
        "description": "This instruction makes a copy of one register pair into another register pair. The source register pair Rr +1:Rr is left unchanged, while the destination register pair Rd+1:Rd is loaded with a copy of Rr + 1:Rr. This instruction is not available in all devices.",
        "operation": "Rd+1:Rd ← Rr+1:Rr",
        "type": "DT",
        "syntax": "MOVW Rd+1:Rd,Rr+1:Rr",
        "operands": {
            "d": "d ∈ {0,2,...,30}",
            "r": "r ∈ {0,2,...,30}"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "0000 0001 dddd rrrr",
        "examples": [
            "mov w r17:16,r1:r0 ; Copy r1:r0 to r17:r16",
            "call check ; Call subroutine",
            "...",
            "check: cpi r16,$11 ; Compare r16 to $11",
            "...",
            "cpi r17,$32 ; Compare r17 to $32",
            "...",
            "ret ; Return from subroutine"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "ldi",
        "name": "Load Immediate",
        "description": "Loads an 8-bit constant directly to register 16 to 31.",
        "operation": "Rd ← K",
        "type": "DT",
        "syntax": "LDI Rd,K",
        "operands": {
            "d": "16 ≤ d ≤ 31",
            "K": "0 ≤ K ≤ 255"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1110 KKKK dddd KKKK",
        "examples": [
            "clr r31 ; Clear Z high byte",
            "ldi r30,$F0 ; Set Z low byte to $F0",
            "lpm ; Load constant from Program",
            "; memory pointed to by Z"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "lds",
        "name": "Load Direct from data space",
        "description": "Loads one byte from the data space to a register. For parts with SRAM, the data space consists of the Register File, I/O memory, and internal SRAM (and external SRAM if applicable). For parts without SRAM, the data space consists of the register file only. The EEPROM has a separate address space. A 16-bit address must be supplied. Memory access is limited to the current data segment of 64KB. The LDS instruction uses the RAMPD Register to access memory above 64KB. To access another data segment in devices with more than 64KB data space, the RAMPD in register in the I/O area has to be changed. This instruction is not available in all devices.",
        "operation": "Rd ← (k)",
        "type": "DT",
        "syntax": "LDS Rd,k",
        "operands": {
            "d": "0 ≤ d ≤ 31",
            "k": "0 ≤ k ≤ 65535"
        },
        "pCounter": "PC ← PC + 2",
        "opCode": [
            "1001 000d dddd 0000",
            "kkkk kkkk kkkk kkkk"
        ],
        "examples": [
            "lds r2,$FF00 ; Load r2 with the contents of data space location $FF00",
            "add r2,r1 ; add r1 to r2",
            "sts $FF00,r2 ; Write back"
        ],
        "words": 2,
        "cycles": {
            "0": 2,
            "x": 2
        },
        "notes": "Cycles XMEGA. If the LDS instruction is accessing internal SRAM, one extra cycle is inserted",
        "incomplete": true
    },
    {
        "mnemonic": "ld",
        "name": "Load Indirect using Index X",
        "operation": "Rd ← (X)",
        "type": "DT",
        "incomplete": true,
        "opCode": "1001 000d dddd 1100"
    },
    {
        "mnemonic": "ld",
        "name": "Load Indirect and PostIncrement using Index X",
        "operation": [
            "Rd ← (X)",
            "X ← X + 1"
        ],
        "type": "DT",
        "incomplete": true,
        "opCode": "1001 000d dddd 1101"
    },
    {
        "mnemonic": "ld",
        "name": "Load Indirect and PreDecrement using Index X",
        "operation": [
            "X ← X - 1",
            "Rd ← (X)"
        ],
        "type": "DT",
        "incomplete": true,
        "opCode": "1001 000d dddd 1110"
    },
    {
        "mnemonic": "ld",
        "name": "Load Indirect using Index Y",
        "operation": "Rd ← (Y)",
        "type": "DT",
        "incomplete": true,
        "opCode": "1000 000d dddd 1000"
    },
    {
        "mnemonic": "ld",
        "name": "Load Indirect and PostIncrement using Index Y",
        "operation": [
            "Rd ← (Y)",
            "Y ← Y + 1"
        ],
        "type": "DT",
        "incomplete": true,
        "opCode": "1001 000d dddd 1001"
    },
    {
        "mnemonic": "ld",
        "name": "Load Indirect and PreDecrement using Index Y",
        "operation": [
            "Y ← Y - 1",
            "Rd ← (Y)"
        ],
        "type": "DT",
        "incomplete": true,
        "opCode": "1001 000d dddd 1010"
    },
    {
        "mnemonic": "ldd",
        "description": "Load Indirect with Displacement using Index Y",
        "operation": "Rd ← (Y + q)",
        "type": "DT",
        "incomplete": true,
        "opCode": "10q0 qq0d dddd 1qqq"
    },
    {
        "mnemonic": "ld",
        "name": "Load Indirect using Index Z",
        "operation": "Rd ← (Z)",
        "type": "DT",
        "incomplete": true,
        "opCode": "1000 000d dddd 0000"
    },
    {
        "mnemonic": "ld",
        "name": "Load Indirect and PostIncrement using Index Z",
        "operation": [
            "Rd ← (Z)",
            "Z ← Z + 1"
        ],
        "type": "DT",
        "incomplete": true,
        "opCode": "1001 000d dddd 0001"
    },
    {
        "mnemonic": "ld",
        "name": "Load Indirect and PreDecrement using Index Z",
        "operation": [
            "Z ← Z - 1",
            "Rd ← (Z)"
        ],
        "type": "DT",
        "incomplete": true,
        "opCode": "1001 000d dddd 0010"
    },
    {
        "mnemonic": "ldd",
        "description": "Load Indirect with Displacement using Index Z",
        "operation": "Rd ← (Z + q)",
        "type": "DT",
        "incomplete": true,
        "opCode": "10q0 qq0d dddd 0qqq"
    },
    {
        "mnemonic": "sts",
        "description": "Store Direct to Data Space",
        "operation": "(k) ← Rd",
        "type": "DT"
    },
    {
        "mnemonic": "st",
        "description": "Store Indirect",
        "operation": "(X) ← Rr",
        "type": "DT"
    },
    {
        "mnemonic": "st",
        "description": "Store Indirect and PostIncrement",
        "operation": [
            "(X) ← Rr",
            "X ← X + 1"
        ],
        "type": "DT"
    },
    {
        "mnemonic": "st",
        "description": "Store Indirect and PreDecrement",
        "operation": [
            "X ← X - 1",
            "(X) ← Rr"
        ],
        "type": "DT"
    },
    {
        "mnemonic": "st",
        "description": "Store Indirect",
        "operation": "(Y) ← Rr",
        "type": "DT"
    },
    {
        "mnemonic": "st",
        "description": "Store Indirect and PostIncrement",
        "operation": [
            "(Y) ← Rr",
            "Y ← Y + 1"
        ],
        "type": "DT"
    },
    {
        "mnemonic": "st",
        "description": "Store Indirect and PreDecrement",
        "operation": [
            "Y ← Y - 1",
            "(Y) ← Rr"
        ],
        "type": "DT"
    },
    {
        "mnemonic": "std",
        "description": "r Store Indirect with Displacement",
        "operation": "(Y + q) ← Rr",
        "type": "DT"
    },
    {
        "mnemonic": "st",
        "description": "Store Indirect",
        "operation": "(Z) ← Rr",
        "type": "DT"
    },
    {
        "mnemonic": "st",
        "description": "Store Indirect and PostIncrement",
        "operation": [
            "(Z) ← Rr",
            "Z ← Z + 1"
        ],
        "type": "DT"
    },
    {
        "mnemonic": "st",
        "description": "Store Indirect and PreDecrement",
        "operation": [
            "Z ← Z - 1",
            "(Z) ← Rr"
        ],
        "type": "DT"
    },
    {
        "mnemonic": "std",
        "description": "r Store Indirect with Displacement",
        "operation": "(Z + q) ← Rr",
        "type": "DT"
    },
    {
        "mnemonic": "lpm",
        "name": "Load Program Memory",
        "description": "Loads one byte pointed to by the Z-register into the destination register Rd. This instruction features a 100% space effective constant initialization or constant data fetch. The Program memory is organized in 16-bit words while the Z-pointer is a byte address. Thus, the least significant bit of the Z-pointer selects either low byte (ZLSB = 0) or high byte (ZLSB = 1). This instruction can address the first 64KB (32K words) of Program memory. The Z-pointer Register can either be left unchanged by the operation, or it can be incremented. The incrementation does not apply to the RAMPZ Register. Devices with Self-Programming capability can use the LPM instruction to read the Fuse and Lock bit values. Refer to the device documentation for a detailed description. The LPM instruction is not available in all devices",
        "operation": "R0 ← (Z)",
        "type": "DT",
        "notes": [
            "The result of these combinations is undefined:",
            "LPM r30, Z+",
            "LPM r31, Z+"
        ],
        "syntax": "LPM",
        "opCode": "1001 0101 1100 1000",
        "words": 1,
        "cycles": 3,
        "incomplete": true
    },
    {
        "mnemonic": "lpm",
        "description": "Load Program Memory",
        "operation": "Rd ← (Z)",
        "type": "DT",
        "syntax": "LPM Rd, Z",
        "opCode": "1001 000d dddd 0100",
        "words": 1,
        "cycles": 3,
        "incomplete": true
    },
    {
        "mnemonic": "lpm",
        "description": "Load Program Memory and PostIncrement",
        "operation": [
            "Rd ← (Z)",
            "Z ← Z + 1"
        ],
        "type": "DT",
        "syntax": "LPM Rd, Z+",
        "opCode": "1001 000d dddd 0101",
        "words": 1,
        "cycles": 3,
        "incomplete": true
    },
    {
        "mnemonic": "elpm",
        "description": "Loads one byte pointed to by the Z-register and the RAMPZ Register in the I/O space, and places this byte in the destination register Rd. This instruction features a 100% space effective constant initialization or constant data fetch. The Program memory is organized in 16-bit words while the Z-pointer is a byte address. Thus, the least significant bit of the Z-pointer selects either low byte (ZLSB = 0) or high byte (ZLSB = 1). This instruction can address the entire Program memory space. The Z-pointer Register can either be left unchanged by the operation, or it can be incremented. The incrementation applies to the entire 24-bit concatenation of the RAMPZ and Z-pointer Registers. Devices with Self-Programming capability can use the ELPM instruction to read the Fuse and Lock bit value. Refer to the device documentation for a detailed description. This instruction is not available in all devices.",
        "operations": [
            {
                "name": "Extended Load Program Memory",
                "syntax": "ELPM",
                "operation": "R0 ← (RAMPZ:Z)",
                "opCode": "1001 0101 1101 1000"
            },
            {
                "name": "Extended Load Program Memory",
                "syntax": "ELPM Rd, Z",
                "operands": {
                    "d": "0 ≤ d ≤ 31"
                },
                "opCode": "1001 000d dddd 0110"
            },
            {
                "name": "Extended Load Program Memory and PostIncrement",
                "operation": [
                    "Rd ← (RAMPZ:Z)",
                    "(RAMPZ:Z) ← (RAMPZ:Z) + 1"
                ],
                "syntax": "ELPM Rd, Z+",
                "operands": {
                    "d": "0 ≤ d ≤ 31"
                },
                "opCode": "1001 000d dddd 0111"
            }
        ],
        "pCounter": "PC ← PC + 1",
        "type": "DT",
        "notes": [
            "The result of these combinations is undefined:",
            "ELPM r30, Z+",
            "ELPM r31, Z+"
        ],
        "examples": [
            "ldi ZL, byte3(Table_1<<1) ; Initialize Z-pointer",
            "out RAMPZ, ZL",
            "ldi ZH, byte2(Table_1<<1)",
            "ldi ZL, byte1(Table_1<<1)",
            "elpm r16, Z+ ; Load constant from Program",
            "; memory pointed to by RAMPZ:Z (Z is r31:r30)",
            "...",
            "Table_1:",
            ".dw 0x3738 ; 0x38 is addressed when ZLSB = 0",
            "; 0x37 is  addressed when ZLSB = 1"
        ]
    },
    {
        "mnemonic": "spm",
        "description": "Store Program Memory",
        "operation": "(RAMPZ:Z) ← R1:R0",
        "type": "DT"
    },
    {
        "mnemonic": "spm",
        "description": "Store Program Memory and PostIncrement by 2",
        "operation": [
            "(RAMPZ:Z) ← R1:R0",
            "Z ← Z + 2"
        ],
        "type": "DT"
    },
    {
        "mnemonic": "in",
        "name": "In From I/O Location",
        "description": "Loads data from the I/O Space (Ports, Timers, Configuration Registers, etc.) into register Rd in the Register File.",
        "operation": "Rd ← I/O(A)",
        "type": "DT",
        "syntax": "IN Rd,A",
        "operands": {
            "d": "0 ≤ d ≤ 31",
            "A": "0 ≤ A ≤ 63"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1011 0AAd dddd AAAA",
        "examples": [
            "in r25,$16 ; Read Port B",
            "cpi r25,4 ; Compare read value to constant",
            "breq exit ; Branch if r25=4",
            "...",
            "exit: nop ; Branch destination (do nothing)"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "out",
        "description": "Out To I/O Location",
        "operation": "I/O(A) ← Rr",
        "type": "DT"
    },
    {
        "mnemonic": "push",
        "description": "Push Register on Stack",
        "operation": "STACK ← Rr",
        "type": "DT"
    },
    {
        "mnemonic": "pop",
        "description": "Pop Register from Stack",
        "operation": "Rd ← STACK",
        "type": "DT"
    },
    {
        "mnemonic": "xch",
        "description": "Exchange",
        "operation": [
            "(Z) ← Rd",
            "Rd ← (Z)"
        ],
        "type": "DT"
    },
    {
        "mnemonic": "las",
        "name": "Load and Set",
        "description": "Load one byte indirect from data space to register and set bits in data space specified by the register. The instruction can only be used towards internal SRAM. The data location is pointed to by the Z (16 bits) Pointer Register in the Register File. Memory access is limited to the current data segment of 64KB. To access another data segment in devices with more than 64KB data space, the RAMPZ in register in the I/O area has to be changed. The Z-pointer Register is left unchanged by the operation. This instruction is especially suited for setting status bits stored in SRAM.",
        "operation": [
            "(Z) ← Rd v (Z)",
            "Rd ← (Z)"
        ],
        "type": "DT",
        "syntax": "LAS Z,Rd",
        "operands": {
            "d": "0 ≤ d ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 001r rrrr 0101",
        "words": 1,
        "cycles": 2,
        "error": true
    },
    {
        "mnemonic": "lac",
        "name": "Load and Clear",
        "description": "Load one byte indirect from data space to register and stores and clear the bits in data space specified by the register. The instruction can only be used towards internal SRAM. The data location is pointed to by the Z (16 bits) Pointer Register in the Register File. Memory access is limited to the current data segment of 64KB. To access another data segment in devices with more than 64KB data space, the RAMPZ in register in the I/O area has to be changed. The Z-pointer Register is left unchanged by the operation. This instruction is especially suited for clearing status bits stored in SRAM.",
        "operation": [
            "(Z) ← ($FF – Rd) • (Z)",
            "Rd ← (Z)"
        ],
        "type": "DT",
        "syntax": "LAC Z,Rd",
        "operands": {
            "d": "0 ≤ d ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 001r rrrr 0110",
        "words": 1,
        "cycles": 2,
        "error": true
    },
    {
        "mnemonic": "lat",
        "name": "Load and Toggle",
        "description": "Load one byte indirect from data space to register and toggles bits in the data space specified by the register. The instruction can only be used towards SRAM. The data location is pointed to by the Z (16 bits) Pointer Register in the Register File. Memory access is limited to the current data segment of 64KB. To access another data segment in devices with more than 64KB data space, the RAMPZ in register in the I/O area has to be changed. The Z-pointer Register is left unchanged by the operation. This instruction is especially suited for changing status bits stored in SRAM.",
        "operation": [
            "(Z) ← Rd ⊕ (Z)",
            "Rd ← (Z)"
        ],
        "type": "DT",
        "syntax": "LAT Z,Rd",
        "operands": {
            "d": "0 ≤ d ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 001r rrrr 0111",
        "words": 1,
        "cycles": 2,
        "error": true
    },
    {
        "mnemonic": "lsl",
        "name": "Logical Shift Left",
        "description": "Shifts all bits in Rd one place to the left. Bit 0 is cleared. Bit 7 is loaded into the C Flag of the SREG. This operation effectively multiplies signed and unsigned values by two",
        "operation": [
            "Rd(n+1) ← Rd(n)",
            "Rd(0) ← 0",
            "C ← Rd(7)"
        ],
        "pCounter": "PC ← PC + 1",
        "flags": "Z,C,N,V,H",
        "type": "BT",
        "syntax": "LSL Rd",
        "operands": {
            "d": "0 ≤ d ≤ 31"
        },
        "opCode": "0000 11dd dddd dddd",
        "status": {
            "H": "Rd3",
            "S": "N ⊕ V",
            "V": "N ⊕ C",
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0",
            "C": "Rd7"
        },
        "examples": [
            "add r0,r4 ; Add r4 to r0",
            "lsl r0 ; Multiply r0 by 2"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "lsr",
        "name": "Logical Shift Right",
        "description": "Shifts all bits in Rd one place to the right. Bit 7 is cleared. Bit 0 is loaded into the C Flag of the SREG. This operation effectively divides an unsigned value by two. The C Flag can be used to round the result.",
        "operation": [
            "Rd(n) ← Rd(n+1)",
            "Rd(7) ← 0",
            "C ← Rd(0)"
        ],
        "flags": "Z,C,N,V",
        "type": "BT",
        "syntax": "LSR Rd",
        "operands": {
            "d": "0 ≤ d ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 010d dddd 0110",
        "status": {
            "S": "N ⊕ V",
            "V": "N ⊕ C",
            "N": 0,
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0",
            "C": "Rd0"
        },
        "examples": [
            "add r0,r4 ; Add r4 to r0",
            "lsr r0 ; Divide r0 by 2"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "rol",
        "description": "Rotate Left Through Carry",
        "operation": [
            "Rd(0) ← C",
            "Rd(n+1) ← Rd(n)",
            "C ← Rd(7)"
        ],
        "flags": "Z,C,N,V,H",
        "type": "BT"
    },
    {
        "mnemonic": "ror",
        "description": "Rotate Right Through Carry",
        "operation": [
            "Rd(7) ← C",
            "Rd(n) ← Rd(n+1)",
            "C ← Rd(0)"
        ],
        "flags": "Z,C,N,V",
        "type": "BT"
    },
    {
        "mnemonic": "asr",
        "name": "Arithmetic Shift Right",
        "description": "Shifts all bits in Rd one place to the right. Bit 7 is held constant. Bit 0 is loaded into the C Flag of the SREG. This operation effectively divides a signed value by two without changing its sign. The Carry Flag can be used to round the result.",
        "operation": "Rd(n) ← Rd(n+1), n=0..6",
        "flags": "Z,C,N,V",
        "type": "BT",
        "syntax": "ASR Rd",
        "operands": {
            "d": "0 ≤ d ≤ 31"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 010d dddd 0101",
        "status": {
            "S": "N ⊕ V",
            "V": "N ⊕ C",
            "N": "R7",
            "Z": "!R7 • !R6 • !R5 • !R4 • !R3 • !R2 • !R1 • !R0",
            "C": "Rd0"
        },
        "examples": [
            "ldi r16,$10 ; Load decimal 16 into r16",
            "asr r16 ; r16=r16 / 2",
            "ldi r17,$FC ; Load -4 in r17",
            "asr r17 ; r17=r17/2"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "swap",
        "description": "Swap Nibbles",
        "operation": "Rd(3..0) ↔ Rd(7..4)",
        "type": "BT"
    },
    {
        "mnemonic": "sbi",
        "description": "Set Bit in I/O Register",
        "operation": "I/O(A, b) ← 1",
        "type": "BT"
    },
    {
        "mnemonic": "cbi",
        "name": "Clear Bit in I/O Register",
        "description": "Clears a specified bit in an I/O register. This instruction operates on the lower 32 I/O registers – addresses 0-31.",
        "operation": "I/O(A, b) ← 0",
        "type": "BT",
        "syntax": "CBI A,b",
        "operands": {
            "A": "0 ≤ A ≤ 31",
            "b": "0 ≤ b ≤ 7"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 1000 AAAA Abbb",
        "examples": "cbi $12,7 ; Clear bit 7 in Port D",
        "words": 1,
        "cycles": {
            "0": 2,
            "x": 1,
            "tiny": 1
        }
    },
    {
        "mnemonic": "bst",
        "name": "Bit Store from Register to T",
        "description": "Stores bit b from Rd to the T Flag in SREG (Status Register).",
        "operation": "T ← Rr(b)",
        "flags": "T",
        "type": "BT",
        "syntax": "BST Rd,b",
        "operands": {
            "d": "0 ≤ d ≤ 31",
            "b": "0 ≤ b ≤ 7"
        },
        "opCode": "1111 101d dddd 0bbb",
        "status": {
            "T": "0 if bit b in Rd is cleared. Set to 1 otherwise."
        },
        "examples": [
            "bst r1,2 ; Store bit 2 of r1 in T Flag",
            "bld r0,4 ; Load T into bit 4 of r0"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "bld",
        "name": "Bit load from T to Register",
        "description": "Copies the T Flag in the SREG (Status Register) to bit b in register Rd.",
        "operation": "Rd(b) ← T",
        "type": "BT",
        "syntax": "BLD Rd,b",
        "operands": {
            "d": "0 ≤ d ≤ 31",
            "b": "0 ≤ b ≤ 7"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1111 100d dddd 0bbb",
        "examples": [
            "bst r1,2 ; Store bit 2 of r1 in T Flag",
            "bld r0,4 ; Load T Flag into bit 4 of r0"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "bset",
        "name": "Flag Set",
        "description": "Sets a single Flag or bit in SREG.",
        "operation": "SREG(s) ← 1",
        "flags": "SREG(s)",
        "type": "BT",
        "syntax": "BSET s",
        "operands": {
            "s": "0 ≤ s ≤ 7"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 0sss 1000",
        "status": {
            "I": "1 if s = 7; Unchanged otherwise.",
            "T": "1 if s = 6; Unchanged otherwise.",
            "H": "1 if s = 5; Unchanged otherwise.",
            "S": "1 if s = 4; Unchanged otherwise.",
            "V": "1 if s = 3; Unchanged otherwise.",
            "N": "1 if s = 2; Unchanged otherwise.",
            "Z": "1 if s = 1; Unchanged otherwise.",
            "C": "1 if s = 0; Unchanged otherwise."
        },
        "examples": [
            "bset 6 ; Set T Flag",
            "bset 7 ; Enable interrupt"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "bclr",
        "name": "Flag Clear",
        "description": "Clears a single Flag in SREG.",
        "operation": "SREG(s) ← 0",
        "flags": "SREG(s)",
        "type": "BT",
        "syntax": "BCLR s",
        "operands": {
            "s": "0 ≤ s ≤ 7"
        },
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 1sss 1000",
        "status": {
            "I": "0 if s = 7; Unchanged otherwise.",
            "T": "0 if s = 6; Unchanged otherwise.",
            "H": "0 if s = 5; Unchanged otherwise.",
            "S": "0 if s = 4; Unchanged otherwise.",
            "V": "0 if s = 3; Unchanged otherwise.",
            "N": "0 if s = 2; Unchanged otherwise.",
            "Z": "0 if s = 1; Unchanged otherwise.",
            "C": "0 if s = 0; Unchanged otherwise."
        },
        "examples": [
            "bclr 0 ; Clear Carry Flag",
            "bclr 7 ; Disable interrupts"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "sec",
        "description": "Set Carry",
        "operation": "C ← 1",
        "flags": "C",
        "type": "BT"
    },
    {
        "mnemonic": "clc",
        "name": "Clear Carry",
        "description": "Clears the Carry Flag (C) in SREG (Status Register).",
        "operation": "C ← 0",
        "flags": "C",
        "type": "BT",
        "syntax": "CLC",
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 1000 1000",
        "status": {
            "C": "0"
        },
        "examples": [
            "add r0,r0 ; Add r0 to itself",
            "clc ; Clear Carry Flag"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "sen",
        "description": "Set Negative Flag",
        "operation": "N ← 1",
        "flags": "N",
        "type": "BT"
    },
    {
        "mnemonic": "cln",
        "name": "Clear Negative Flag",
        "description": "Clears the Negative Flag (N) in SREG (Status Register).",
        "operation": "N ← 0",
        "flags": "N",
        "type": "BT",
        "syntax": "CLN",
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 1010 1000",
        "status": {
            "N": "0"
        },
        "examples": [
            "add r2,r3 ; Add r3 to r2",
            "cln ; Clear Negative Flag"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "sez",
        "description": "Set Zero Flag",
        "operation": "Z ← 1",
        "flags": "Z",
        "type": "BT"
    },
    {
        "mnemonic": "clz",
        "name": "Clear Zero Flag",
        "description": "Clears the Zero Flag (Z) in SREG (Status Register).",
        "operation": "Z ← 0",
        "flags": "Z",
        "type": "BT",
        "syntax": "CLZ",
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 1001 1000",
        "status": {
            "Z": 0
        },
        "examples": [
            "add r2,r3 ; Add r3 to r2",
            "clz ; Clear zero"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "sei",
        "description": "Global Interrupt Enable",
        "operation": "I ← 1",
        "flags": "I",
        "type": "BT"
    },
    {
        "mnemonic": "cli",
        "name": "Global Interrupt Disable",
        "description": "Clears the Global Interrupt Flag (I) in SREG (Status Register). The interrupts will be immediately disabled. No interrupt will be executed after the CLI instruction, even if it occurs simultaneously with the CLI instruction.",
        "operation": "I ← 0",
        "flags": "I",
        "type": "BT",
        "syntax": "CLI",
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 1111 1000",
        "status": {
            "I": "0"
        },
        "examples": [
            "in temp, SREG ; Store SREG value (temp must be defined by user)",
            "cli ; Disable interrupts during timed sequence",
            "sbi EECR, EEMWE ; Start EEPROM write",
            "sbi EECR, EEWE",
            "out SREG, temp ; Restore SREG value (I-Flag)"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "ses",
        "description": "Set Signed Test Flag",
        "operation": "S ← 1",
        "flags": "S",
        "type": "BT"
    },
    {
        "mnemonic": "cls",
        "name": "Clear Signed Test Flag",
        "description": "Clears the Signed Flag (S) in SREG (Status Register).",
        "operation": "S ← 0",
        "flags": "S",
        "type": "BT",
        "syntax": "CLS",
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 1100 1000",
        "status": {
            "S": 0
        },
        "examples": [
            "add r2,r3 ; Add r3 to r2",
            "cls ; Clear Signed Flag"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "sev",
        "description": "Set Two's Compliment Overflow",
        "operation": "V ← 1",
        "flags": "V",
        "type": "BT"
    },
    {
        "mnemonic": "clv",
        "name": "Clear Two's Compliment Overflow",
        "description": "Clears the Overflow Flag (V) in SREG (Status Register)",
        "operation": "V ← 0",
        "flags": "V",
        "type": "BT",
        "syntax": "CLV",
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 1011 1000",
        "status": {
            "V": 0
        },
        "examples": [
            "add r2,r3 ; Add r3 to r2",
            "clv ; Clear Overflow Flag"
        ],
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "set",
        "description": "Set T in SREG",
        "operation": "T ← 1",
        "flags": "T",
        "type": "BT"
    },
    {
        "mnemonic": "clt",
        "name": "Clear T in SREG",
        "description": "Clears the T Flag in SREG (Status Register).",
        "operation": "T ← 0",
        "flags": "T",
        "type": "BT",
        "syntax": "CTL",
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 1110 1000",
        "status": {
            "T": 0
        },
        "examples": "clt ; Clear T Flag",
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "seh",
        "description": "Set Half Carry Flag in SREG",
        "operation": "H ← 1",
        "flags": "H",
        "type": "BT"
    },
    {
        "mnemonic": "clh",
        "name": "Clear Half Carry Flag in SREG",
        "description": "Clears the Half Carry Flag (H) in SREG (Status Register).",
        "operation": "H ← 0",
        "flags": "H",
        "type": "BT",
        "syntax": "CLH",
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0100 1101 1000",
        "status": {
            "H": "0"
        },
        "examples": "clh ; Clear the Half Carry Flag",
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "break",
        "name": "Break",
        "description": "The BREAK instruction is used by the On-chip Debug system, and is normally not used in the application software. When the BREAK instruction is executed, the AVR CPU is set in the Stopped Mode. This gives the On-chip Debugger access to internal resources. If any Lock bits are set, or either the JTAGEN or OCDEN Fuses are unprogrammed, the CPU will treat the BREAK instruction as a NOP and will not enter the Stopped mode. This instruction is not available in all devices.",
        "type": "MC",
        "syntax": "BREAK",
        "pCounter": "PC ← PC + 1",
        "opCode": "1001 0101 1001 1000",
        "words": 1,
        "cycles": 1
    },
    {
        "mnemonic": "nop",
        "description": "No Operation",
        "type": "MC"
    },
    {
        "mnemonic": "sleep",
        "description": "Sleep",
        "type": "MC"
    },
    {
        "mnemonic": "wdr",
        "description": "Watchdog Reset",
        "type": "MC"
    }
]